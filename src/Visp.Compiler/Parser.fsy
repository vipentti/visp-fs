// FsYacc parser
%{
// Copyright 2023 Ville Penttinen
// Distributed under the MIT License.
// https://github.com/vipentti/visp-fs/blob/main/LICENSE.md

#nowarn "1182"  // generated code has lots of unused "parseState"

open Visp.Compiler.DiagnosticsLogger
open Visp.Compiler.StringResources
open Visp.Compiler.Syntax
open Visp.Compiler.ParseHelpers
open FSharp.Text.Parsing

// This function is called by the generated parser code. Returning initiates error recovery
// It must be called precisely "parse_error_rich"
let parse_error_rich = Some(fun (ctxt: ParseErrorContext<_>) ->
    raise (SyntaxError(box ctxt, (lhs ctxt.ParseState))))

%}

%start start
%start raw_expr
%start raw_macro_body

%token EOF
%token LPAREN RPAREN
%token LBRACKET RBRACKET
%token LBRACE RBRACE HASH_BRACE HASH_PAREN HASH_BRACKET BRACE_BAR BAR_BRACE BRACKET_BAR BAR_BRACKET
%token TRUE FALSE NIL COLON COLON_COLON COMMA UNIT BAR
%token OP_PLUS OP_MINUS OP_MULT OP_DIV QUOTE_SYM
%token BANG_RANGE FOR_IN FOR_TO BANG_LIST BANG_MAP BANG_SET BANG_ARRAY BANG_VEC BANG_TUPLE
%token DOTDOT
%token AT
%token OPEN MODULE
%token FN FNSTAR LET USE LET_BANG USE_BANG DO_BANG LETSTAR MUT SET DOT NEW DOT_BRACKET DOT_PLUS IF_KW BEGIN_KW DO_KW QUOTE_KW UNQUOTE_KW SPLICE_UNQUOTE_KW QUASIQUOTE_KW
%token ATOM_KW DEREF_KW WHILE TYPE RECORD MEMBER MEMBERS MEMBERFN MEMBER_GET MEMBER_SET OVERRIDE MACRO MATCH WHEN CONS CONCAT REQUIRE
%token THREAD_FIRST THREAD_LAST SYNTAX_MACRO SEQ UNION
%token INLINE REC RINIT
%token <bool> YIELD
%token <bool> RETURN

/* bool indicates if INT8 was 'bad' max_int+1, e.g. '128' */
%token <sbyte * bool> INT8
%token <int16 * bool> INT16
%token <int32 * bool> INT32 INT32_DOT_DOT
%token <int64 * bool> INT64
%token <int64 * bool> NATIVEINT

%token <byte> UINT8
%token <uint16> UINT16
%token <uint32> UINT32
%token <uint64> UINT64
%token <uint64> UNATIVEINT
%token <single> IEEE32
%token <double> IEEE64
%token <System.Decimal> DECIMAL

%token <string> HASH_IDENT
%token <string> PROP_PLUS
%token <string> MACRO_NAME
%token <string> CHAR
%token <string * SynStringKind * ParseHelpers.LexerContinuation> STRING
%token <string> SYMBOL KEYWORD RAWSTRING DOT_METHOD APPLY_METHOD

// %left TRUE FALSE
// %left LPAREN LBRACKET
// %nonassoc RPAREN RBRACKET
%nonassoc prec_module_decl

%nonassoc prec_module_decls
%nonassoc prec_hash_ident_args
%nonassoc prec_hash_ident

// https://github.com/dotnet/fsharp/blob/363e8768ecd3e537aff643e0ea6da89115f249c2/src/Compiler/pars.fsy#L189


%nonassoc QUOTE_SYM
%nonassoc LPAREN HASH_PAREN
%nonassoc LBRACKET BRACKET_BAR
%nonassoc LBRACE HASH_BRACE BRACE_BAR
%nonassoc HASH_BRACKET
%nonassoc RPAREN
%nonassoc RBRACKET BAR_BRACKET
%nonassoc RBRACE BAR_BRACE
%nonassoc AT
%nonassoc BANG_TUPLE

%nonassoc OPEN MODULE
%nonassoc prec_constant

%nonassoc prec_at_expr
%nonassoc prec_expr

%nonassoc INT8 INT16 INT32 INT64 NATIVEINT UINT8 UINT16 UINT32 UINT64 UNATIVEINT IEEE32 IEEE64 DECIMAL
%nonassoc TRUE FALSE NIL SYMBOL KEYWORD RAWSTRING DOT_METHOD APPLY_METHOD STRING UNIT CHAR
%nonassoc HASH_IDENT

// %left COMMA
// %right COMMA
%nonassoc prec_syn_type
%nonassoc prec_attribute

%nonassoc prec_attribute_comma

%nonassoc prec_dot_no_paren
%nonassoc prec_paren
%nonassoc prec_bracket

%nonassoc prec_binding prec_member
%nonassoc prec_arg prec_name

%nonassoc prec_binding_empty
%nonassoc binding_list_empty

%nonassoc prec_fn
%nonassoc prec_invalid_fn
%nonassoc prec_lambda
%nonassoc prec_call
%nonassoc prec_paren_expr
%nonassoc prec_lambda_def_call
%nonassoc prec_lambda_def
%nonassoc prec_normal_tuple
%nonassoc prec_match_pattern_const
%nonassoc prec_match_pattern
%nonassoc prec_match
%nonassoc prec_match_tuple_list

%nonassoc prec_colon_colon
%nonassoc prec_syntyped
%nonassoc prec_record_with_members

%nonassoc prec_record_expr_only
%nonassoc prec_record_init

%nonassoc prec_recover
// %nonassoc EOF

%nonassoc prec_eof

%nonassoc prec_error
%nonassoc EOF

%type <ParsedFile> start
%type <SynExpr> raw_expr
%type <SynMacroBody> raw_macro_body

%%

//  start of actual code
start: prog { $1 }

raw_expr: expr { $1 }

raw_macro_body: macro_body { $1 }

prog:
    | file_fragments
        { ParsedFile($1) }

file_fragments: rev_file_fragments { List.rev $1 }
rev_file_fragments:
    | file_fragment { [$1] }
    | rev_file_fragments file_fragment { $2 :: $1 }

file_fragment:
    | module_decls
        { ParsedFileFragment.AnonModule($1, lhs parseState)}

    // TODO: If this uses recover interesting things happen
    | error EOF %prec prec_error
        { ParsedFileFragment.AnonModule([], lhs parseState) }

module_decls: rev_module_decls %prec prec_module_decls { List.rev $1 }
rev_module_decls:
    | module_decl %prec prec_module_decl { [$1] }
    | rev_module_decls module_decl %prec prec_module_decls { $2 :: $1 }

module_decl:
    | HASH_IDENT hash_ident_args %prec prec_hash_ident
        { SynModuleDecl.HashDirective(ParsedHashDirective($1, $2, lhs parseState), lhs parseState)}
    | module_parens { $1 }
    | expr { SynModuleDecl.Expr($1, lhs parseState) }

hash_ident_args: rev_hash_ident_args %prec prec_hash_ident_args { List.rev $1 }
rev_hash_ident_args:
    | %prec prec_hash_ident_args { [] }
    | hash_ident_arg %prec prec_hash_ident { [$1] }
    | rev_hash_ident_args hash_ident_arg %prec prec_hash_ident_args { $2 :: $1 }

hash_ident_arg:
    | STRING %prec prec_hash_ident {
        let (raw, k, _) = $1
        ParsedHashDirectiveArgument.String(raw, k, rhs parseState 1)
    }

module_parens:
    | LPAREN module_help RPAREN { $2 }

module_help:
    | OPEN symbol
        { SynModuleDecl.Open($2, lhs parseState) }
    | MODULE symbol module_decls
        { SynModuleDecl.NestedModule($2, $3, lhs parseState) }
    | REQUIRE symbol STRING
        { let (raw, _, _) = $3
          SynModuleDecl.Require($2, raw, lhs parseState) }

expr_list: rev_expr_list { List.rev $1 }
rev_expr_list:
    | expr %prec prec_expr { [$1] }
    | rev_expr_list expr { $2 :: $1 }

expr_list_or_empty:
    | { [] }
    | expr_list { $1 }

recover:
   | error %prec prec_error { true }
   | EOF { false }

expr:
    | constant %prec prec_constant { SynExpr.Const(fst $1, snd $1) }
    | symbol { SynExpr.Symbol($1) }
    | keyword { SynExpr.Keyword($1) }
    | AT expr %prec prec_at_expr { SynExpr.Deref(true, $2, lhs parseState) }
    | QUOTE_SYM quoted_expr %prec prec_at_expr
        { SynExpr.Quote(true, $2, lhs parseState) }
    | LBRACE expr_list_or_empty RBRACE { CollExpr.mkHashMap $2 (lhs parseState)}
    | HASH_BRACE expr_list_or_empty RBRACE { CollExpr.mkHashSet $2 (lhs parseState)}
    | HASH_PAREN lambda_short_expr_list RPAREN
        { SynExpr.LambdaShort($2, lhs parseState)}
    | vector_start
        { $1 }

    | brace_bar { $1 }
    | bracket_bar { $1 }
    | inside_parens %prec prec_paren { $1 }

brace_bar:
    | BRACE_BAR record_init_bar_list BAR_BRACE { SynExpr.RecordInit($2, lhs parseState) }
    | BRACE_BAR record_init_bar_list recover { SynExpr.RecordInit([], lhs parseState) }

bracket_bar:
    | BRACKET_BAR recover { CollExpr.mkFsArray [] (lhs parseState)}
    | BRACKET_BAR BAR_BRACKET { CollExpr.mkFsArray [] (lhs parseState)}
    | BRACKET_BAR expr_list BAR_BRACKET { CollExpr.mkFsArray $2 (lhs parseState)}

lambda_short_expr_list:
    | parens_expr { $1 }


vector_start:
    | LBRACKET RBRACKET { CollExpr.mkVector [] (lhs parseState) }
    | LBRACKET expr_list RBRACKET { CollExpr.mkVector $2 (lhs parseState) }

inside_parens:
    | LPAREN RPAREN { SynExpr.Const (SynConst.Unit, lhs parseState) }
    | LPAREN parens_expr_start RPAREN { $2 }
    | LPAREN parens_expr_start EOF %prec prec_recover { $2 }
    // TODO: handle this better?
    // | LPAREN parens_expr_start error %prec prec_recover { $2 }
    | LPAREN recover %prec prec_recover {
        Syntax.parserRecoveryExpr (lhs parseState)
    }

parens_expr_start:
    | parens_expr %prec prec_paren_expr { $1 }

dotted_exprs: rev_dotted_exprs { List.rev $1 }
rev_dotted_exprs:
    | { [] }
    | expr { [$1] }
    | rev_dotted_exprs DOT expr { $3 :: $1 }
    | rev_dotted_exprs COMMA expr { $3 :: $1 }

colon_colon_exprs: rev_colon_colon_exprs { List.rev $1 }
rev_colon_colon_exprs:
    | { [] }
    | expr { [$1] }
    | rev_colon_colon_exprs COLON_COLON expr  { $3 :: $1 }

parens_expr:
    | expr DOT dotted_exprs
        { SynExpr.Tuple($1 :: $3, lhs parseState)}
    | expr COMMA dotted_exprs
        { SynExpr.Tuple($1 :: $3, lhs parseState)}
    | expr COLON_COLON colon_colon_exprs
        { CollExpr.mkFsList ($1 :: $3) (lhs parseState)}
    | function_def %prec prec_fn { $1 }
    | function_call %prec prec_call { $1 }
    | let { $1 }
    | letstar { $1 }
    | mut { $1 }
    | set { $1 }
    | if_expr { $1 }
    | type_expr { $1 }
    | record_expr { $1 }
    | union_expr { $1 }
    | for_in_expr { $1 }
    | for_to_expr { $1 }
    | record_init_expr { $1 }
    | range_expr { $1 }
    | list_expr { $1 }
    | match_expr { $1 }
    | new_expr { $1 }
    | cons_expr { $1 }
    | concat_expr { $1 }
    | operators_not_in_parens { SynExpr.Op($1) }
    | syntax_macro_expr { $1 }
    | macro_call_expr { $1 }
    | QUOTE_KW quoted_expr
        { SynExpr.Quote(false, $2, lhs parseState) }
    | QUASIQUOTE_KW quasiquoted_expr
        { SynExpr.Quasiquote(false, $2, lhs parseState) }
    | BEGIN_KW expr_list
        { SynExpr.Begin($2, BeginKind.Begin, lhs parseState) }
    | DO_KW expr_list
        { SynExpr.Begin($2, BeginKind.Do, lhs parseState) }
    | dot_expr { $1 }
    | ATOM_KW expr
        { SynExpr.Atom($2, lhs parseState) }
    | DEREF_KW expr
        { SynExpr.Deref(false, $2, lhs parseState) }
    | WHILE expr expr_list
        { SynExpr.While($2, $3, lhs parseState) }
    | THREAD_FIRST expr_list
        { SynExpr.ThreadFirst ($2, lhs parseState)}
    | THREAD_LAST threadable_list
        { SynExpr.ThreadLast ($2, lhs parseState)}

    | BANG_TUPLE %prec prec_normal_tuple { SynExpr.Tuple([], lhs parseState)}
    | BANG_TUPLE expr_list %prec prec_normal_tuple { SynExpr.Tuple($2, lhs parseState)}

    | BANG_MAP { CollExpr.mkFsMap [] (lhs parseState)}
    | BANG_MAP expr_list { CollExpr.mkFsMap $2 (lhs parseState)}

    | BANG_SET { CollExpr.mkFsSet [] (lhs parseState)}
    | BANG_SET expr_list { CollExpr.mkFsSet $2 (lhs parseState)}

    | BANG_ARRAY { CollExpr.mkFsArray [] (lhs parseState)}
    | BANG_ARRAY expr_list { CollExpr.mkFsArray $2 (lhs parseState)}

    | BANG_VEC { CollExpr.mkFsVec [] (lhs parseState)}
    | BANG_VEC expr_list { CollExpr.mkFsVec $2 (lhs parseState)}

    | SEQ expr_list { SynExpr.FsSeq($2, lhs parseState) }
    | YIELD expr { SynExpr.FsYield($2, $1, lhs parseState) }
    | RETURN expr { SynExpr.FsReturn($2, $1, lhs parseState) }
    | DO_BANG expr { SynExpr.FsDo($2, true, lhs parseState) }

macro_call_expr:
    | macro_call { SynExpr.SyntaxMacroCall($1) }

macro_call:
    | macro_name
        { let mNameBody = SynMacroBody.Symbol($1)
          SynMacroCall($1, [mNameBody], lhs parseState) }
    | macro_name macro_body_list
        { let mNameBody = SynMacroBody.Symbol($1)
          SynMacroCall($1, mNameBody :: $2, lhs parseState) }

syntax_macro_expr:
    | syntax_macro { SynExpr.SyntaxMacro($1)}

syntax_macro:
    | SYNTAX_MACRO symbol macro_cases
        { SynMacro($2, $3, lhs parseState )}

macro_cases: rev_macro_cases { List.rev $1 }
rev_macro_cases:
    | macro_case_start { [$1] }
    | rev_macro_cases macro_case_start { $2 :: $1 }

macro_case_start:
    | LPAREN macro_case_pat macro_body RPAREN
        { SynMacroCase($2, $3, lhs parseState) }
    | LBRACKET macro_case_pat macro_body RBRACKET
        { SynMacroCase($2, $3, lhs parseState) }

macro_case_pat:
    | LPAREN macro_pat_list RPAREN { $2 }
    | LBRACKET macro_pat_list RBRACKET { $2 }

macro_pat_list: rev_macro_pat_list { List.rev $1 }
rev_macro_pat_list:
    | macro_pat { [$1] }
    | rev_macro_pat_list macro_pat { $2 :: $1 }

macro_pat:
    | constant { SynMacroPat.Const(fst $1, snd $1) }
    | LPAREN macro_pat_list RPAREN { SynMacroPat.List($2, lhs parseState) }
    | LBRACKET macro_pat_list RBRACKET { SynMacroPat.List($2, lhs parseState) }
    | DOT { SynMacroPat.Trivia(SynMacroTriviaKind.Dot, lhs parseState) }
    | COMMA { SynMacroPat.Trivia(SynMacroTriviaKind.Comma, lhs parseState) }
    | COLON { SynMacroPat.Trivia(SynMacroTriviaKind.Colon, lhs parseState) }
    | COLON_COLON { SynMacroPat.Trivia(SynMacroTriviaKind.ColonColon, lhs parseState) }
    | BAR { SynMacroPat.Trivia(SynMacroTriviaKind.Bar, lhs parseState) }
    | symbol {
        let text = $1
        let symText = (Syntax.textOfSymbol text)
        if (symText = "_") then
            SynMacroPat.Discard (lhs parseState)
        else if (symText = "...") then
            SynMacroPat.Ellipsis (lhs parseState)
        else
            SynMacroPat.Symbol (text, lhs parseState) }

macro_body_list: rev_macro_body_list { List.rev $1 }
rev_macro_body_list:
    | macro_body { [$1] }
    | rev_macro_body_list macro_body { $2 :: $1 }


macro_open_kind:
    | LPAREN { SynListKind.Paren }
    | LBRACKET { SynListKind.Bracket }
    | LBRACE { SynListKind.Brace }
    | HASH_BRACE { SynListKind.HashBrace }
    | HASH_PAREN { SynListKind.HashParen }
    | HASH_BRACKET { SynListKind.HashBracket }
    | BRACE_BAR { SynListKind.BraceBar }
    | BRACKET_BAR { SynListKind.BracketBar }
    | DOT_BRACKET { SynListKind.DotBracket }

macro_close_kind:
    | RPAREN { () }
    | RBRACKET { () }
    | RBRACE { () }
    | BAR_BRACE { () }
    | BAR_BRACKET { () }

macro_body:
    | constant { SynMacroBody.Const(fst $1, snd $1) }
    | LPAREN macro_name RPAREN
        { let mNameBody = SynMacroBody.Symbol($2)
          SynMacroBody.Call(SynMacroCall($2, [mNameBody], lhs parseState))}
    | LPAREN macro_name macro_body_list RPAREN
        { let mNameBody = SynMacroBody.Symbol($2)
          SynMacroBody.Call(SynMacroCall($2, mNameBody :: $3, lhs parseState)) }

    | macro_open_kind macro_close_kind { SynMacroBody.List($1, [], lhs parseState) }
    | macro_open_kind macro_body_list macro_close_kind { SynMacroBody.List($1, $2, lhs parseState) }

    | DOT { SynMacroBody.Trivia(SynMacroTriviaKind.Dot, lhs parseState) }
    | COMMA { SynMacroBody.Trivia(SynMacroTriviaKind.Comma, lhs parseState) }
    | COLON { SynMacroBody.Trivia(SynMacroTriviaKind.Colon, lhs parseState) }
    | COLON_COLON { SynMacroBody.Trivia(SynMacroTriviaKind.ColonColon, lhs parseState) }
    | BAR { SynMacroBody.Trivia(SynMacroTriviaKind.Bar, lhs parseState) }
    | keyword { SynMacroBody.Keyword($1) }
    | symbol {
        let text = $1
        let symText = (Syntax.textOfSymbol text)
        if (symText = "_") then
            SynMacroBody.Discard (lhs parseState)
        else if (symText = "...") then
            SynMacroBody.Ellipsis (lhs parseState)
        else
            SynMacroBody.Symbol (text) }

cons_expr:
    | CONS expr expr
        { SynExpr.Cons($2, $3, lhs parseState)}
    | CONS expr
        { SynExpr.Cons($2, Syntax.parserRecoveryExpr (lhs parseState), lhs parseState)}
    | CONS
        { SynExpr.Cons(Syntax.parserRecoveryExpr (lhs parseState), Syntax.parserRecoveryExpr (lhs parseState), lhs parseState)}

concat_expr:
    | CONCAT expr expr
        { SynExpr.Concat($2, $3, lhs parseState)}
    | CONCAT expr
        { SynExpr.Concat($2, Syntax.parserRecoveryExpr (lhs parseState), lhs parseState)}
    | CONCAT
        { SynExpr.Concat(Syntax.parserRecoveryExpr (lhs parseState), Syntax.parserRecoveryExpr (lhs parseState), lhs parseState)}

new_expr:
    | NEW syntype_ident
        { SynExpr.New($2, [], lhs parseState) }
    | NEW syntype_ident expr_list
        { SynExpr.New($2, $3, lhs parseState) }

threadable_list: rev_threadable_list { List.rev $1 }
rev_threadable_list:
    | threadable { [$1] }
    | rev_threadable_list threadable { $2 :: $1 }

threadable:
    | prop_plus
        { SynThreadable.Property($1, lhs parseState) }
    | dot_method
        { SynThreadable.Method($1, DotMethodKind.Tuple, lhs parseState) }
    | apply_method
        { SynThreadable.Method($1, DotMethodKind.Apply, lhs parseState) }
    | dot_bracket_expr_raw
        { SynThreadable.Index($1, lhs parseState) }
    | expr
        { SynThreadable.Expr($1, lhs parseState) }

prop_plus:
    | PROP_PLUS
        {
          let text = ($1).TrimStart('+')
          SynSymbol(Ident(text, rhs parseState 1))
        }

expr_comma_list: rev_expr_comma_list { List.rev $1 }
rev_expr_comma_list:
    | expr { [$1] }
    | OP_MULT { [(Syntax.mkSynSymbolExpr "*" (rhs parseState 1))] }
    | rev_expr_comma_list COMMA expr { $3 :: $1 }

dot_bracket_expr_raw:
    | DOT_BRACKET expr RBRACKET
        { [$2] }
    | DOT_BRACKET expr COMMA rev_expr_comma_list RBRACKET
        { $2 :: $4 }
    | DOT_BRACKET OP_MULT COMMA rev_expr_comma_list RBRACKET
        { (Syntax.mkSynSymbolExpr "*" (rhs parseState 2)) :: $4 }

dot_expr:
    | dot_bracket_expr_raw expr
        { SynExpr.DotIndex($2, $1, lhs parseState)}
    | dot_bracket_expr_raw recover
        { SynExpr.DotIndex(Syntax.parserRecoveryExpr (lhs parseState), $1, lhs parseState)}
    | DOT_BRACKET expr recover
        { SynExpr.DotIndex(Syntax.parserRecoveryExpr (lhs parseState), [$2], lhs parseState)}
    | DOT_PLUS symbol expr
        { SynExpr.DotProperty($3, $2, lhs parseState)}
    | prop_plus expr
        { SynExpr.DotProperty($2, $1, lhs parseState)}
    | dot_method expr expr_list
        { SynExpr.DotMethod($2, $1, $3, DotMethodKind.Tuple, lhs parseState) }
    | dot_method expr
        { SynExpr.DotMethod($2, $1, [], DotMethodKind.Tuple, lhs parseState) }
    | apply_method expr expr_list
        { SynExpr.DotMethod($2, $1, $3, DotMethodKind.Apply, lhs parseState) }
    | apply_method expr
        { SynExpr.DotMethod($2, $1, [], DotMethodKind.Apply, lhs parseState) }
    | DOT expr symbol
        {
          let text = Syntax.textOfSymbol $3
          if text.StartsWith('+') then
            SynExpr.DotProperty($2, ($3).trimStart '+', lhs parseState)
          else
            SynExpr.DotMethod($2, $3, [], DotMethodKind.Tuple, lhs parseState) }
    | DOT expr prop_plus
        { SynExpr.DotProperty($2, $3, lhs parseState) }

    | DOT expr dot_bracket_expr_raw
        { SynExpr.DotIndex($2, $3, lhs parseState) }
    | DOT expr symbol expr_list
        { SynExpr.DotMethod($2, $3, $4, DotMethodKind.Tuple, lhs parseState) }

lparen_or_lbracket:
    | LPAREN { () }
    | LBRACKET { () }

rparen_or_rbracket:
    | RPAREN { () }
    | RBRACKET { () }

list_expr:
    | BANG_LIST { CollExpr.mkFsList [] (lhs parseState)}
    | BANG_LIST expr_list { CollExpr.mkFsList $2 (lhs parseState)}

for_in_expr:
    | FOR_IN lparen_or_lbracket name expr rparen_or_rbracket expr_list
        { SynExpr.ForIn($3, $4, $6, lhs parseState) }

for_to_expr:
    | FOR_TO lparen_or_lbracket name lparen_or_lbracket expr SYMBOL expr rparen_or_rbracket rparen_or_rbracket expr_list
        {
            let down = $6 = "downto"
            SynExpr.ForTo($3, $5, $7, $10, down, lhs parseState)
        }

range_expr:
    | BANG_RANGE expr DOTDOT expr DOTDOT expr
        { SynExpr.RangeExpr ($2, Some($4), $6, lhs parseState) }
    | BANG_RANGE expr expr expr
        { SynExpr.RangeExpr ($2, Some($3), $4, lhs parseState) }
    | BANG_RANGE expr DOTDOT expr
        { SynExpr.RangeExpr ($2, None, $4, lhs parseState) }
    | BANG_RANGE expr expr
        { SynExpr.RangeExpr ($2, None, $3, lhs parseState) }
    | expr DOTDOT expr DOTDOT expr
        { SynExpr.RangeExpr ($1, Some($3), $5, lhs parseState) }
    | expr DOTDOT expr
        { SynExpr.RangeExpr ($1, None, $3, lhs parseState) }

if_expr:
    | IF_KW expr expr
        { SynExpr.If($2, $3, None, lhs parseState) }
    | IF_KW expr expr expr
        { SynExpr.If($2, $3, Some $4, lhs parseState) }

quoted_exprs: rev_quoted_exprs { List.rev $1 }
rev_quoted_exprs:
    | quoted_expr { [$1] }
    | rev_quoted_exprs quoted_expr { $2 :: $1 }

quoted_expr:
    | constant { SynQuoted.Const(fst $1, snd $1) }
    | symbol { SynQuoted.Symbol($1) }
    | keyword { SynQuoted.Keyword($1) }
    | LPAREN quoted_exprs RPAREN
        { SynQuoted.List ($2, lhs parseState) }
    | LBRACKET quoted_exprs RBRACKET
        { SynQuoted.Vector ($2, lhs parseState) }
    | LBRACE quoted_exprs RBRACE
        { SynQuoted.HashMap ($2, lhs parseState) }
    | HASH_BRACE quoted_exprs RBRACE
        { SynQuoted.HashSet ($2, lhs parseState) }

value_exprs: rev_value_exprs { List.rev $1 }
rev_value_exprs:
    | { [] }
    | value_expr { [$1] }
    | rev_value_exprs value_expr { $2 :: $1 }

value_expr:
    | constant { SynValue.Const(fst $1, snd $1) }
    | symbol { SynValue.Symbol($1) }
    | keyword { SynValue.Keyword($1) }
    | LPAREN value_exprs RPAREN
        { SynValue.List ($2, lhs parseState) }
    | LBRACKET value_exprs RBRACKET
        { SynValue.Vector ($2, lhs parseState) }
    | LBRACE value_exprs RBRACE
        { SynValue.HashMap ($2, lhs parseState) }
    | HASH_BRACE value_exprs RBRACE
        { SynValue.HashSet ($2, lhs parseState) }

quasiquoted_exprs: rev_quasiquoted_exprs { List.rev $1 }
rev_quasiquoted_exprs:
    | quasiquoted_expr { [$1] }
    | rev_quasiquoted_exprs quasiquoted_expr { $2 :: $1 }

quasiquoted_expr:
    | constant { SynQuasiquote.Const(fst $1, snd $1) }
    | symbol { SynQuasiquote.Symbol($1) }
    | keyword { SynQuasiquote.Keyword($1) }
    | operators { SynQuasiquote.Op($1) }
    | unquote { $1 }
    | splice_unquote { $1 }
    | LPAREN quasiquoted_exprs RPAREN
        { SynQuasiquote.List ($2, lhs parseState) }

unquote:
    | LPAREN UNQUOTE_KW expr RPAREN
        { SynQuasiquote.Unquote ($3, lhs parseState)}

splice_unquote:
    | LPAREN SPLICE_UNQUOTE_KW expr RPAREN
        { SynQuasiquote.SpliceUnquote ($3, lhs parseState)}

operators:
    | LPAREN operators_not_in_parens RPAREN { $2 }

operators_not_in_parens:
    | OP_PLUS
        { SynOp.Plus([], lhs parseState)}
    | OP_MULT
        { SynOp.Mult([], lhs parseState)}
    | OP_PLUS expr_list
        { SynOp.Plus($2, lhs parseState)}
    | OP_MULT expr_list
        { SynOp.Mult($2, lhs parseState)}
    | OP_MINUS expr_list
        { SynOp.Minus($2, lhs parseState)}
    | OP_DIV expr_list
        { SynOp.Div($2, lhs parseState)}

set:
    | SET expr expr
        { SynExpr.Set($2, $3, lhs parseState) }
    // TODO: Report error
    | SET expr
        { let r = lhs parseState
          SynExpr.Set($2, Syntax.parserRecoveryExpr r, r) }
    // TODO
    | SET
        { let r = lhs parseState
          SynExpr.Set(Syntax.parserRecoveryExpr r, Syntax.parserRecoveryExpr r, r) }

let:
    | USE name expr
        { SynExpr.LetOrUse($2, $3, LetFlags.Use, lhs parseState) }
    | LET name expr
        { SynExpr.LetOrUse($2, $3, LetFlags.None, lhs parseState) }
    | LET_BANG name expr
        { SynExpr.LetOrUse($2, $3, LetFlags.Bang, lhs parseState) }
    | USE_BANG name expr
        { SynExpr.LetOrUse($2, $3, LetFlags.Bang ||| LetFlags.Use, lhs parseState) }
    // TODO: Report error
    | LET name
        { let r = lhs parseState
          SynExpr.LetOrUse($2, Syntax.parserRecoveryExpr r, LetFlags.None, r) }
    | USE name
        { let r = lhs parseState
          SynExpr.LetOrUse($2, Syntax.parserRecoveryExpr r, LetFlags.Use, r) }
    | LET_BANG name
        { let r = lhs parseState
          SynExpr.LetOrUse($2, Syntax.parserRecoveryExpr r, LetFlags.Bang, r) }
    | USE_BANG name
        { let r = lhs parseState
          SynExpr.LetOrUse($2, Syntax.parserRecoveryExpr r, LetFlags.Bang ||| LetFlags.Use, r) }
    // TODO: Report error
    | LET
        { let r = lhs parseState
          SynExpr.LetOrUse(Syntax.parserRecoveryName r, Syntax.parserRecoveryExpr r, LetFlags.None, r) }
    | LET_BANG
        { let r = lhs parseState
          SynExpr.LetOrUse(Syntax.parserRecoveryName r, Syntax.parserRecoveryExpr r, LetFlags.Bang, r) }
    | USE
        { let r = lhs parseState
          SynExpr.LetOrUse(Syntax.parserRecoveryName r, Syntax.parserRecoveryExpr r, LetFlags.Use, r) }
    | USE_BANG
        { let r = lhs parseState
          SynExpr.LetOrUse(Syntax.parserRecoveryName r, Syntax.parserRecoveryExpr r, LetFlags.Use ||| LetFlags.Bang, r) }

mut:
    | MUT name expr
        { SynExpr.LetOrUse($2, $3, LetFlags.Mutable, lhs parseState) }
    // TODO: Report error
    | MUT name
        { let r = lhs parseState
          SynExpr.LetOrUse($2, Syntax.parserRecoveryExpr r, LetFlags.Mutable, r) }
    // TODO: Report error
    | MUT
        { let r = lhs parseState
          SynExpr.LetOrUse(Syntax.parserRecoveryName r, Syntax.parserRecoveryExpr r, LetFlags.Mutable, r) }

letstar:
    | LETSTAR binding_list_start expr_list
        { SynExpr.LetStar($2, $3, lhs parseState) }

type_expr:
    | TYPE symbol syntype_ident
        { SynExpr.TypeAlias($2, $3, lhs parseState) }
    | TYPE symbol name_list_start member_list_start
        { SynExpr.Type($2, $3, $4, [], lhs parseState) }
    | attribute_list TYPE symbol name_list_start member_list_start
        { SynExpr.Type($3, $4, $5, $1, lhs parseState) }

union_expr:
    | UNION symbol union_labels_or_members
        {
            let labels, members = Syntax.partitionChoices $3
            SynExpr.Union($2, labels, members, [] , lhs parseState)
        }
    | attribute_list UNION symbol union_labels_or_members
        {
            let labels, members = Syntax.partitionChoices $4
            SynExpr.Union($3, labels, members, $1 , lhs parseState)
        }

union_labels_or_members: rev_union_labels_or_members { List.rev $1 }
rev_union_labels_or_members:
    | union_label_or_member_parens { [$1] }
    | rev_union_labels_or_members union_label_or_member_parens { $2 :: $1 }

union_label_or_member_parens:
    | symbol { Choice1Of2(UnionCase($1, [], lhs parseState)) }
    | LPAREN union_label_or_member RPAREN { $2 }
    | LBRACKET union_label_or_member RBRACKET { $2 }

union_label_or_member:
    | MEMBER symbol expr
        { Choice2Of2(SynTypeMember.Member($2, $3, lhs parseState)) }
    | MEMBER FN symbol arg_list_start expr_list
        { Choice2Of2(SynTypeMember.MemberFn($3, $4, $5, (lhs parseState))) }
    | symbol
        { Choice1Of2(UnionCase($1, [], lhs parseState)) }
    | symbol union_fields
        { Choice1Of2(UnionCase($1, $2, lhs parseState)) }

union_fields: rev_union_fields { List.rev $1 }
rev_union_fields:
    | union_field { [$1] }
    | rev_union_fields union_field { $2 :: $1 }

union_field:
    | syntype_ident { UnionField.Type($1, lhs parseState) }
    | LPAREN symbol COLON syntype_ident RPAREN
        { UnionField.Named($2, $4, lhs parseState) }
    | LBRACKET symbol COLON syntype_ident RBRACKET
        { UnionField.Named($2, $4, lhs parseState) }

record_expr:
    | RECORD symbol record_labels_or_members
        {
            let labels, members = Syntax.partitionMembers $3
            SynExpr.Record($2, labels, members, [] , lhs parseState)
        }
    | attribute_list RECORD symbol record_labels_or_members
        {
            let labels, members = Syntax.partitionMembers $4
            SynExpr.Record($3, labels, members, $1 , lhs parseState)
        }

record_labels_or_members: rev_record_labels_or_members { List.rev $1 }
rev_record_labels_or_members:
    | record_label_or_member_parens { [$1] }
    | rev_record_labels_or_members record_label_or_member_parens { $2 :: $1 }

record_label_or_member_parens:
    | LPAREN record_label_or_member RPAREN { $2 }
    | LBRACKET record_label_or_member RBRACKET { $2 }

record_label_or_member:
    | MEMBER symbol expr
        { RecordContent.Member(SynTypeMember.Member($2, $3, lhs parseState)) }
    | MEMBER FN symbol arg_list_start expr_list
        { RecordContent.Member(SynTypeMember.MemberFn($3, $4, $5, (lhs parseState))) }
    | symbol COLON syntype_ident
        { RecordContent.Label (RecordLabel(RecordLabelKind.Default, $1, $3, lhs parseState)) }
    | MUT symbol COLON syntype_ident
        { RecordContent.Label (RecordLabel(RecordLabelKind.Mutable, $2, $4, lhs parseState)) }

typed_list: rev_typed_list { List.rev $1 }
rev_typed_list:
    | error { [] }
    | syntyped %prec prec_syntyped { [$1] }
    | rev_typed_list syntyped %prec prec_syntyped { $2 :: $1 }

syntyped:
    | LPAREN symbol COLON syntype_ident RPAREN
        { SynTyped($2, $4, lhs parseState )}
    | LBRACKET symbol COLON syntype_ident RBRACKET
        { SynTyped($2, $4, lhs parseState )}

record_members:
    | LPAREN MEMBERS member_list_start RPAREN { $3 }

record_init_expr:
    | RINIT record_init_list { SynExpr.RecordInit($2, lhs parseState) }

record_init_bar_list: rev_record_init_bar_list { List.rev $1 }
rev_record_init_bar_list:
    | record_init_init { [$1] }
    | rev_record_init_bar_list record_init_init { $2 :: $1 }

record_init_init:
    | record_init %prec prec_record_init
        { let s, e = $1
          SynInit(s, e, lhs parseState)
        }
    // | expr %prec prec_record_expr_only
    //     { SynInit(Syntax.mkSynSymbol "_" (lhs parseState), $1, lhs parseState)
    //     }

record_init_list: rev_record_init_list { List.rev $1 }
rev_record_init_list:
    | record_init_parens { [$1] }
    | rev_record_init_list record_init_parens { $2 :: $1 }

record_init_parens:
    | LPAREN record_init RPAREN {
        let s, e = $2
        SynInit(s, e, lhs parseState)
     }
    | LBRACKET record_init RBRACKET {
        let s, e = $2
        SynInit(s, e, lhs parseState)
    }

record_init:
    | symbol expr { ($1, $2) }

attribute_list: rev_attribute_list { List.rev $1 }
rev_attribute_list:
    | attr_list { [$1] }
    | rev_attribute_list attr_list { $2 :: $1 }

attr_list:
    | HASH_BRACKET attributes RBRACKET
        { { Attributes = $2; Range = (lhs parseState) } }

attributes: rev_attributes { List.rev $1 }
rev_attributes:
    | attribute %prec prec_attribute { [$1] }
    | rev_attributes BAR attribute %prec prec_attribute_comma { $3 :: $1 }
    | rev_attributes DOT attribute { $3 :: $1 }

attribute:
    | syntype_ident expr
        { { TypeName = $1; ArgExpr = $2; Range = lhs parseState } }
    | syntype_ident
        { { TypeName = $1; ArgExpr = Syntax.UnitExpr <| lhs parseState; Range = lhs parseState } }

member_list_start:
    | { [] }
    | member_list { $1 }

member_list: rev_member_list { List.rev $1 }
rev_member_list:
    | member %prec prec_member { [$1] }
    | rev_member_list member { $2 :: $1 }

member:
    | LPAREN member_in_parens RPAREN { $2 }

member_name:
    | MEMBER symbol { $2 }

member_get:
    | LPAREN MEMBER_GET arg_list_start expr_list_or_empty RPAREN
        { SynMemberGet($3, $4, lhs parseState) }

member_set:
    | LPAREN MEMBER_SET arg_list_start name expr_list_or_empty RPAREN
        { SynMemberSet($3, $4, $5, lhs parseState) }

member_member_in_parens:
    | member_name member_get { SynTypeMember.GetSet($1, Some($2), None, lhs parseState) }
    | member_name member_set { SynTypeMember.GetSet($1, None, Some($2), lhs parseState) }
    | member_name member_get member_set { SynTypeMember.GetSet($1, Some($2), Some($3), lhs parseState) }
    | member_name member_set member_get { SynTypeMember.GetSet($1, Some($3), Some($2), lhs parseState) }
    | member_name expr { SynTypeMember.Member($1, $2, lhs parseState) }

member_in_parens:
    | LET name expr
        { SynTypeMember.Let($2, $3, lhs parseState) }
    | MUT name expr
        { SynTypeMember.Mut($2, $3, lhs parseState) }
    | member_member_in_parens { $1 }
    // | MEMBER symbol expr
    //     { SynTypeMember.Member($2, $3, lhs parseState) }
    | MEMBERFN symbol arg_list_start expr_list
        { SynTypeMember.MemberFn($2, $3, $4, (lhs parseState)) }
    | MEMBER FN symbol arg_list_start expr_list
        { SynTypeMember.MemberFn($3, $4, $5, (lhs parseState)) }
    | OVERRIDE symbol expr
        { SynTypeMember.OverrideMember($2, $3, lhs parseState) }
    | OVERRIDE FN symbol arg_list_start expr_list
        { SynTypeMember.OverrideFn($3, $4, $5, (lhs parseState)) }

tok_lparen:
    | LPAREN { () }

empty_bindings:
    | LPAREN RPAREN { [] }
    | LBRACKET RBRACKET { [] }

binding_list_start:
    | empty_bindings { $1 }
    | LPAREN binding_list RPAREN { $2 }
    | LBRACKET binding_list RBRACKET { $2 }

binding_list: rev_binding_list { List.rev $1 }
rev_binding_list:
    | binding %prec prec_binding { [$1] }
    | rev_binding_list binding { $2 :: $1 }

binding:
    | name expr { SynBinding($1, $2, lhs parseState) }

name:
    | symbol { SynName.Inferred($1, lhs parseState) }
    | name_in_parens_or_brackets_start { $1 }

name_in_parens_or_brackets_start:
    | LPAREN name_in_parens_or_brackets RPAREN { $2 }
    | LBRACKET name_in_parens_or_brackets RBRACKET { $2 }

name_in_parens_or_brackets:
    | symbol COLON syntype_ident
        { SynName.Typed($1, $3, lhs parseState) }
    | symbol
        { SynName.Inferred($1, lhs parseState) }

empty_name_list:
    | LPAREN RPAREN { [] }
    | LBRACKET RBRACKET { [] }

name_list_start:
    | empty_name_list { $1 }
    | LPAREN name_list RPAREN { $2 }
    | LBRACKET name_list RBRACKET { $2 }

name_list: rev_name_list { List.rev $1 }
rev_name_list:
    | name %prec prec_name { [$1] }
    | rev_name_list name { $2 :: $1 }

symbol:
    | SYMBOL { SynSymbol(Ident($1, lhs parseState)) }

macro_name:
    | MACRO_NAME
        { let text = $1
          SynSymbol(Ident(text, lhs parseState))
        }

dot_method:
    | DOT_METHOD
        { let text = $1
          SynSymbol(Ident(text.TrimStart '.', lhs parseState))
        }

apply_method:
    | APPLY_METHOD
        { let text = $1
          SynSymbol(Ident(text.TrimStart '-', lhs parseState))
        }

keyword:
    | KEYWORD
        { let text = $1
          SynKeyword(Ident(text, lhs parseState))
        }

syn_comma:
    | COMMA %prec prec_syn_comma { () }

raw_syntype_ident_text:
    | SYMBOL %prec prec_syn_type { $1 }

raw_syntype_ident:
    | SYMBOL %prec prec_syn_type
        { let text = $1
          SynType.Ident(Ident(text, lhs parseState))
        }

syntype_ident:
    | raw_syntype_ident_text %prec prec_syn_type { SynType.Ident(Ident($1, lhs parseState))}
    | QUOTE_SYM raw_syntype_ident_text
        { let text = $2
          SynType.Ident(Ident("'" + text, lhs parseState))
        }
    | raw_syntype_ident_text COMMA syntype_comma_list
        {
            let text = $1
            let rest = $3
            SynType.Ident(Ident(text + "," + (String.concat "," rest), lhs parseState))
        }

syntype_comma_list: rev_syntype_comma_list { List.rev $1 }
rev_syntype_comma_list:
    | raw_syntype_ident_text %prec prec_syn_type { [$1] }
    | rev_syntype_comma_list COMMA SYMBOL %prec prec_syn_comma { $3 :: $1 }

constant:
    | rawConstant { ($1, (rhs parseState 1))}

rawConstant:
    | STRING
        { let (raw, kind, _) = $1
          SynConst.String(raw, kind, (lhs parseState))}
    | INT8
      { if snd $1 then errorR(mkDiagnosticWithText (SR.lexOutsideEightBitSigned(), lhs parseState))
        SynConst.SByte(fst $1) }

    | UINT8
      { SynConst.Byte $1 }

    | INT16
      { if snd $1 then errorR(mkDiagnosticWithText (SR.lexOutsideSixteenBitSigned(), lhs parseState))
        SynConst.Int16 (fst $1) }

    | UINT16
      { SynConst.UInt16 $1 }

    | INT32
      { if snd $1 then errorR(mkDiagnosticWithText (SR.lexOutsideThirtyTwoBitSigned(), lhs parseState))
        SynConst.Int32 (fst $1) }

    | UINT32
      { SynConst.UInt32 $1 }

    | INT64
      { if snd $1 then errorR(mkDiagnosticWithText (SR.lexOutsideSixtyFourBitSigned(), lhs parseState))
        SynConst.Int64 (fst $1) }

    | UINT64
      { SynConst.UInt64 $1 }

    | NATIVEINT
      { if snd $1 then errorR(mkDiagnosticWithText (SR.lexOutsideNativeSigned(), lhs parseState))
        SynConst.IntPtr(fst $1) }

    | UNATIVEINT
      { SynConst.UIntPtr $1 }

    | IEEE32
      { SynConst.Single $1 }

    | IEEE64
      { SynConst.Double $1 }

    | DECIMAL { SynConst.Decimal($1)}

    | TRUE { SynConst.Bool(true)}
    | FALSE { SynConst.Bool(false)}
    | NIL { SynConst.Nil }
    | UNIT { SynConst.Unit }
    | CHAR
        { let text = $1
          SynConst.Char(parseChar text) }

function_def:
    | FN symbol arg_list_start expr_list %prec prec_fn
        { SynExpr.FunctionDef($2, FunctionFlags.None, $3, $4, (lhs parseState)) }
    | FN INLINE symbol arg_list_start expr_list %prec prec_fn
        { SynExpr.FunctionDef($3, FunctionFlags.Inline, $4, $5, (lhs parseState)) }
    | FN REC INLINE symbol arg_list_start expr_list %prec prec_fn
        { SynExpr.FunctionDef($4, FunctionFlags.Recursive ||| FunctionFlags.Inline, $5, $6, (lhs parseState)) }
    | FN REC symbol arg_list_start expr_list %prec prec_fn
        { SynExpr.FunctionDef($3, FunctionFlags.Recursive, $4, $5, (lhs parseState)) }
    | FN arg_list_start expr_list %prec prec_lambda_def
        { SynExpr.LambdaDef(SynLambda($2, $3, (lhs parseState))) }
    | FNSTAR arg_list_start expr_list
        { SynExpr.LambdaDef(SynLambda($2, $3, (lhs parseState))) }
    | invalid_function_def %prec prec_invalid_fn { $1 }

invalid_function_def:
    // TODO: Report
    | FN %prec prec_invalid_fn
        { SynExpr.LambdaDef(SynLambda([], [], (lhs parseState))) }
    // TODO: Report
    | FN symbol %prec prec_invalid_fn
        { SynExpr.FunctionDef($2, FunctionFlags.None, [], [], lhs parseState) }
    // TODO: Report
    | FN arg_list_start %prec prec_invalid_fn
        { SynExpr.LambdaDef(SynLambda([], [], (lhs parseState))) }
    // TODO: Report
    | FN symbol arg_list_start %prec prec_invalid_fn
        { SynExpr.FunctionDef($2, FunctionFlags.None, $3, [], (lhs parseState)) }
    | FN INLINE symbol arg_list_start %prec prec_invalid_fn
        { SynExpr.FunctionDef($3, FunctionFlags.Inline, $4, [], (lhs parseState)) }

arg_list_start:
    | UNIT { [] }
    | LPAREN RPAREN { [] }
    | LBRACKET RBRACKET { [] }
    | lparen_or_lbracket arg_list rparen_or_rbracket { $2 }
    | lparen_or_lbracket recover %prec prec_recover { [] }
    | recover %prec prec_recover { [] }

arg_list: rev_arg_list { List.rev $1 }
rev_arg_list:
    | arg %prec prec_arg { [$1] }
    | rev_arg_list arg { $2 :: $1 }

arg:
    | symbol { SynArg.InferredArg($1, lhs parseState) }
    | arg_in_parens_or_brackets_start { $1 }

arg_in_parens_or_brackets_start:
    | LPAREN arg_in_parens_or_brackets RPAREN { $2 }
    | LBRACKET arg_in_parens_or_brackets RBRACKET { $2 }

arg_in_parens_or_brackets:
    | symbol COLON syntype_ident
        { SynArg.TypedArg($1, $3, lhs parseState) }
    | symbol
        { SynArg.InferredArg($1, lhs parseState) }

function_call:
    | expr expr_list { Syntax.mkFunctionCallOrCexpr $1 $2 (lhs parseState)}
    | expr { SynExpr.FunctionCall($1, [], (lhs parseState))}

function_call_args:
    | empty_call_args { $1 }
    | expr_list { $1 }

empty_call_args:
    | { [] }

match_expr:
    | MATCH expr match_list
        { SynExpr.Match ($2, $3, lhs parseState)}
    // TODO: report
    | MATCH expr
        { let r = lhs parseState;
          SynExpr.Match ($2, [], r)}
    // TODO: report
    | MATCH
        { let r = lhs parseState;
          SynExpr.Match (Syntax.parserRecoveryExpr r, [], r)}

match_list: rev_match_list { List.rev $1 }
rev_match_list:
    | match_start { [$1] }
    | rev_match_list match_start { $2 :: $1 }

match_start:
    | lparen_or_lbracket match rparen_or_rbracket { $2 }
    // TODO: report
    | lparen_or_lbracket rparen_or_rbracket {
        Syntax.parserRecoveryMatch (lhs parseState)
     }

match:
    | match_pattern expr_list
        { SynMatch.SynMatch($1, None, $2, lhs parseState) }

    | match_pattern LPAREN WHEN expr RPAREN expr_list
        { SynMatch.SynMatch($1, Some($4), $6, lhs parseState) }

match_tuple_list: rev_match_tuple_list %prec prec_match_tuple_list { List.rev $1 }
rev_match_tuple_list:
    | match_pattern %prec prec_match_pattern { [$1] }
    | rev_match_tuple_list COMMA match_pattern %prec prec_match_tuple_list
        { $3 :: (SynMatchPattern.Trivia(SynPatternTriviaKind.Comma, (rhs parseState 2))) :: $1 }
    | rev_match_tuple_list DOT match_pattern %prec prec_match_tuple_list
        { $3 :: (SynMatchPattern.Trivia(SynPatternTriviaKind.Dot, (rhs parseState 2))) :: $1 }
    | rev_match_tuple_list COLON_COLON match_pattern %prec prec_match_tuple_list
        { $3 :: (SynMatchPattern.Trivia(SynPatternTriviaKind.ColonColon, (rhs parseState 2))) :: $1 }
    | rev_match_tuple_list match_pattern %prec prec_match_tuple_list
        { $2 :: $1 }

match_pattern:
    | constant %prec prec_match_pattern_const { SynMatchPattern.Const(fst $1, snd $1) }
    | symbol {
        let text = $1
        if ((Syntax.textOfSymbol text) = "_") then
            SynMatchPattern.Discard (lhs parseState)
        else
            SynMatchPattern.Symbol (text, lhs parseState) }
    | LBRACKET RBRACKET
        { SynMatchPattern.Trivia(SynPatternTriviaKind.Brackets, (lhs parseState)) }
    | LPAREN LBRACKET RBRACKET RPAREN
        { SynMatchPattern.Trivia(SynPatternTriviaKind.Brackets, (lhs parseState)) }
    | LPAREN BANG_TUPLE match_tuple_list RPAREN
        { SynMatchPattern.Tuple ($3, lhs parseState) }
    | LPAREN match_tuple_list RPAREN
        { SynMatchPattern.List($2, lhs parseState) }
