// FsYacc parser
%{
// Copyright 2023 Ville Penttinen
// Distributed under the MIT License.
// https://github.com/vipentti/visp-fs/blob/main/LICENSE.md

#nowarn "1182"  // generated code has lots of unused "parseState"

open Visp.Compiler.Syntax
open Visp.Compiler.ParseHelpers
open FSharp.Text.Parsing

// This function is called by the generated parser code. Returning initiates error recovery
// It must be called precisely "parse_error_rich"
let parse_error_rich = Some(fun (ctxt: ParseErrorContext<_>) ->
    raise (SyntaxError(box ctxt, (lhs ctxt.ParseState))))

%}

%start start
%start raw_expr

%token EOF
%token LPAREN RPAREN
%token LBRACKET RBRACKET
%token LBRACE RBRACE HASH_BRACE HASH_PAREN HASH_BRACKET
%token TRUE FALSE NIL COLON COMMA UNIT BAR
%token OP_PLUS OP_MINUS OP_MULT OP_DIV QUOTE_SYM
%token BANG_RANGE FOR_IN BANG_LIST BANG_MAP BANG_SET BANG_ARRAY BANG_VEC BANG_TUPLE
%token DOTDOT
%token AT
%token OPEN MODULE
%token FN FNSTAR LET LETSTAR MUT SET DOT NEW DOT_BRACKET DOT_PLUS IF_KW BEGIN_KW DO_KW QUOTE_KW UNQUOTE_KW SPLICE_UNQUOTE_KW QUASIQUOTE_KW
%token ATOM_KW DEREF_KW WHILE TYPE RECORD MEMBER MEMBERS MEMBERFN OVERRIDE MACRO MATCH WHEN CONS CONCAT REQUIRE
%token THREAD_FIRST THREAD_LAST SYNTAX_MACRO SEQ YIELD
%token INLINE REC RINIT
%token <int> INT32
%token <int64> INT64
%token <decimal> DECIMAL
%token <string> HASH_IDENT
%token <string> PROP_PLUS
%token <string> MACRO_NAME
%token <string> CHAR
%token <string * SynStringKind * ParseHelpers.LexerContinuation> STRING
%token <string> SYMBOL KEYWORD RAWSTRING DOT_METHOD APPLY_METHOD

// %left TRUE FALSE
// %left LPAREN LBRACKET
// %nonassoc RPAREN RBRACKET
%nonassoc prec_module_decl

%nonassoc prec_module_decls
%nonassoc prec_hash_ident_args
%nonassoc prec_hash_ident

// https://github.com/dotnet/fsharp/blob/363e8768ecd3e537aff643e0ea6da89115f249c2/src/Compiler/pars.fsy#L189


%nonassoc QUOTE_SYM
%nonassoc LPAREN HASH_PAREN
%nonassoc LBRACKET
%nonassoc LBRACE HASH_BRACE
%nonassoc HASH_BRACKET
%nonassoc RPAREN
%nonassoc RBRACKET
%nonassoc RBRACE
%nonassoc AT
%nonassoc BANG_TUPLE

%nonassoc OPEN MODULE
%nonassoc prec_constant

%nonassoc prec_at_expr
%nonassoc prec_expr

%nonassoc TRUE FALSE NIL INT32 INT64 DECIMAL SYMBOL KEYWORD RAWSTRING DOT_METHOD APPLY_METHOD STRING UNIT CHAR
%nonassoc HASH_IDENT

// %left COMMA
// %right COMMA
%nonassoc prec_syn_type
%nonassoc prec_attribute

%nonassoc prec_attribute_comma

%nonassoc prec_dot_no_paren
%nonassoc prec_paren
%nonassoc prec_bracket

%nonassoc prec_binding prec_member
%nonassoc prec_arg prec_name

%nonassoc prec_binding_empty
%nonassoc binding_list_empty

%nonassoc prec_fn
%nonassoc prec_invalid_fn
%nonassoc prec_lambda
%nonassoc prec_call
%nonassoc prec_paren_expr
%nonassoc prec_lambda_def_call
%nonassoc prec_lambda_def
%nonassoc prec_normal_tuple
%nonassoc prec_match_pattern_const
%nonassoc prec_match_pattern
%nonassoc prec_match
%nonassoc prec_match_tuple_list

%nonassoc prec_syntyped
%nonassoc prec_record_with_members

%nonassoc prec_recover
// %nonassoc EOF

%nonassoc prec_eof

%nonassoc prec_error
%nonassoc EOF

%type <ParsedFile> start
%type <SynExpr> raw_expr

%%

//  start of actual code
start: prog { $1 }

raw_expr: expr { $1 }

prog:
    | file_fragments
        { ParsedFile($1) }

file_fragments: rev_file_fragments { List.rev $1 }
rev_file_fragments:
    | file_fragment { [$1] }
    | rev_file_fragments file_fragment { $2 :: $1 }

file_fragment:
    | module_decls
        { ParsedFileFragment.AnonModule($1, lhs parseState)}

    // TODO: If this uses recover interesting things happen
    | error EOF %prec prec_error
        { ParsedFileFragment.AnonModule([], lhs parseState) }

module_decls: rev_module_decls %prec prec_module_decls { List.rev $1 }
rev_module_decls:
    | module_decl %prec prec_module_decl { [$1] }
    | rev_module_decls module_decl %prec prec_module_decls { $2 :: $1 }

module_decl:
    | HASH_IDENT hash_ident_args %prec prec_hash_ident
        { SynModuleDecl.HashDirective(ParsedHashDirective($1, $2, lhs parseState), lhs parseState)}
    | module_parens { $1 }
    | expr { SynModuleDecl.Expr($1, lhs parseState) }

hash_ident_args: rev_hash_ident_args %prec prec_hash_ident_args { List.rev $1 }
rev_hash_ident_args:
    | %prec prec_hash_ident_args { [] }
    | hash_ident_arg %prec prec_hash_ident { [$1] }
    | rev_hash_ident_args hash_ident_arg %prec prec_hash_ident_args { $2 :: $1 }

hash_ident_arg:
    | STRING %prec prec_hash_ident {
        let (raw, k, _) = $1
        ParsedHashDirectiveArgument.String(raw, k, rhs parseState 1)
    }

module_parens:
    | LPAREN module_help RPAREN { $2 }

module_help:
    | OPEN symbol
        { SynModuleDecl.Open($2, lhs parseState) }
    | MODULE symbol module_decls
        { SynModuleDecl.NestedModule($2, $3, lhs parseState) }
    | REQUIRE symbol STRING
        { let (raw, _, _) = $3
          SynModuleDecl.Require($2, raw, lhs parseState) }

expr_list: rev_expr_list { List.rev $1 }
rev_expr_list:
    | expr %prec prec_expr { [$1] }
    | rev_expr_list expr { $2 :: $1 }

expr_list_or_empty:
    | { [] }
    | expr_list { $1 }

recover:
   | error %prec prec_error { true }
   | EOF { false }

expr:
    | constant %prec prec_constant { SynExpr.Const(fst $1, snd $1) }
    | symbol { SynExpr.Symbol($1) }
    | keyword { SynExpr.Keyword($1) }
    | AT expr %prec prec_at_expr { SynExpr.Deref(true, $2, lhs parseState) }
    | QUOTE_SYM quoted_expr %prec prec_at_expr
        { SynExpr.Quote(true, $2, lhs parseState) }
    | LBRACE expr_list_or_empty RBRACE
        { SynExpr.HashMap($2, lhs parseState)}
    | HASH_BRACE expr_list_or_empty RBRACE
        { SynExpr.HashSet($2, lhs parseState)}
    | HASH_PAREN lambda_short_expr_list RPAREN
        { SynExpr.LambdaShort($2, lhs parseState)}
    | vector_start
        { $1 }
    | inside_parens %prec prec_paren { $1 }

lambda_short_expr_list:
    | parens_expr { $1 }

vector_start:
    | LBRACKET RBRACKET { SynExpr.Vector([], lhs parseState) }
    | LBRACKET expr_list RBRACKET
        { SynExpr.Vector($2, lhs parseState) }

inside_parens:
    | LPAREN RPAREN { SynExpr.Const (SynConst.Unit, lhs parseState) }
    | LPAREN parens_expr_start RPAREN { $2 }
    | LPAREN parens_expr_start EOF %prec prec_recover { $2 }
    // TODO: handle this better?
    // | LPAREN parens_expr_start error %prec prec_recover { $2 }
    | LPAREN recover %prec prec_recover {
        Syntax.parserRecoveryExpr (lhs parseState)
    }

parens_expr_start:
    | parens_expr %prec prec_paren_expr { $1 }

dotted_exprs: rev_dotted_exprs { List.rev $1 }
rev_dotted_exprs:
    | { [] }
    | expr { [$1] }
    | rev_dotted_exprs DOT expr { $3 :: $1 }
    | rev_dotted_exprs COMMA expr { $3 :: $1 }

parens_expr:
    // | expr DOT expr
    //     { SynExpr.Pair($1, $3, lhs parseState)}
    | expr DOT dotted_exprs
        { SynExpr.Tuple($1 :: $3, lhs parseState)}
    | expr COMMA dotted_exprs
        { SynExpr.Tuple($1 :: $3, lhs parseState)}
    | function_def %prec prec_fn { $1 }
    | macro_def { $1 }
    | function_call %prec prec_call { $1 }
    | let { $1 }
    | letstar { $1 }
    | mut { $1 }
    | set { $1 }
    | if_expr { $1 }
    | type_expr { $1 }
    | record_expr { $1 }
    | for_in_expr { $1 }
    | record_init_expr { $1 }
    | range_expr { $1 }
    | list_expr { $1 }
    | match_expr { $1 }
    | new_expr { $1 }
    | cons_expr { $1 }
    | concat_expr { $1 }
    | operators_not_in_parens { SynExpr.Op($1) }
    | syntax_macro_expr { $1 }
    | macro_call_expr { $1 }
    | QUOTE_KW quoted_expr
        { SynExpr.Quote(false, $2, lhs parseState) }
    | QUASIQUOTE_KW quasiquoted_expr
        { SynExpr.Quasiquote(false, $2, lhs parseState) }
    | BEGIN_KW expr_list
        { SynExpr.Begin($2, BeginKind.Begin, lhs parseState) }
    | DO_KW expr_list
        { SynExpr.Begin($2, BeginKind.Do, lhs parseState) }
    | dot_expr { $1 }
    | ATOM_KW expr
        { SynExpr.Atom($2, lhs parseState) }
    | DEREF_KW expr
        { SynExpr.Deref(false, $2, lhs parseState) }
    | WHILE expr expr_list
        { SynExpr.While($2, $3, lhs parseState) }
    | THREAD_FIRST expr_list
        { SynExpr.ThreadFirst ($2, lhs parseState)}
    | THREAD_LAST threadable_list
        { SynExpr.ThreadLast ($2, lhs parseState)}

    | BANG_TUPLE %prec prec_normal_tuple { SynExpr.Tuple([], lhs parseState)}
    | BANG_TUPLE expr_list %prec prec_normal_tuple { SynExpr.Tuple($2, lhs parseState)}

    | BANG_MAP { SynExpr.FsMap([], lhs parseState)}
    | BANG_MAP expr_list { SynExpr.FsMap($2, lhs parseState)}

    | BANG_SET { SynExpr.FsSet([], lhs parseState)}
    | BANG_SET expr_list { SynExpr.FsSet($2, lhs parseState)}

    | BANG_ARRAY { SynExpr.FsArray([], lhs parseState)}
    | BANG_ARRAY expr_list { SynExpr.FsArray($2, lhs parseState)}

    | BANG_VEC { SynExpr.FsVec([], lhs parseState)}
    | BANG_VEC expr_list { SynExpr.FsVec($2, lhs parseState)}

    | SEQ expr_list { SynExpr.FsSeq($2, lhs parseState) }
    | YIELD expr { SynExpr.FsYield($2, lhs parseState) }

macro_call_expr:
    | macro_call { SynExpr.SyntaxMacroCall($1) }

macro_call:
    | macro_name
        { let mNameBody = SynMacroBody.Symbol($1)
          SynMacroCall($1, [mNameBody], lhs parseState) }
    | macro_name macro_body_list
        { let mNameBody = SynMacroBody.Symbol($1)
          SynMacroCall($1, mNameBody :: $2, lhs parseState) }

syntax_macro_expr:
    | syntax_macro { SynExpr.SyntaxMacro($1)}

syntax_macro:
    | SYNTAX_MACRO symbol macro_cases
        { SynMacro($2, $3, lhs parseState )}

macro_cases: rev_macro_cases { List.rev $1 }
rev_macro_cases:
    | macro_case_start { [$1] }
    | rev_macro_cases macro_case_start { $2 :: $1 }

macro_case_start:
    | LPAREN macro_case_pat macro_body RPAREN
        { SynMacroCase($2, $3, lhs parseState) }
    | LBRACKET macro_case_pat macro_body RBRACKET
        { SynMacroCase($2, $3, lhs parseState) }

macro_case_pat:
    | LPAREN macro_pat_list RPAREN { $2 }
    | LBRACKET macro_pat_list RBRACKET { $2 }

macro_pat_list: rev_macro_pat_list { List.rev $1 }
rev_macro_pat_list:
    | macro_pat { [$1] }
    | rev_macro_pat_list macro_pat { $2 :: $1 }

macro_pat:
    | constant { SynMacroPat.Const(fst $1, snd $1) }
    | LPAREN macro_pat_list RPAREN { SynMacroPat.List($2, lhs parseState) }
    | LBRACKET macro_pat_list RBRACKET { SynMacroPat.List($2, lhs parseState) }
    | symbol {
        let text = $1
        let symText = (Syntax.textOfSymbol text)
        if (symText = "_") then
            SynMacroPat.Discard (lhs parseState)
        else if (symText = "...") then
            SynMacroPat.Ellipsis (lhs parseState)
        else
            SynMacroPat.Symbol (text, lhs parseState) }

macro_body_list: rev_macro_body_list { List.rev $1 }
rev_macro_body_list:
    | macro_body { [$1] }
    | rev_macro_body_list macro_body { $2 :: $1 }

macro_body:
    | constant { SynMacroBody.Const(fst $1, snd $1) }
    | LPAREN RPAREN { SynMacroBody.List(SynListKind.List, [], lhs parseState) }
    | LBRACKET RBRACKET { SynMacroBody.List(SynListKind.Vector, [], lhs parseState) }
    | LBRACE RBRACE { SynMacroBody.List(SynListKind.HashMap, [], lhs parseState) }
    | HASH_BRACE RBRACE { SynMacroBody.List(SynListKind.HashSet, [], lhs parseState) }
    | HASH_PAREN RPAREN { SynMacroBody.List(SynListKind.HashParen, [], lhs parseState) }
    | HASH_BRACKET RBRACKET { SynMacroBody.List(SynListKind.AttributeList, [], lhs parseState) }

    | LPAREN macro_body_list RPAREN { SynMacroBody.List(SynListKind.List, $2, lhs parseState) }
    | LBRACKET macro_body_list RBRACKET { SynMacroBody.List(SynListKind.Vector, $2, lhs parseState) }
    | LBRACE macro_body_list RBRACE { SynMacroBody.List(SynListKind.HashMap, $2, lhs parseState) }
    | HASH_BRACE macro_body_list RBRACE { SynMacroBody.List(SynListKind.HashSet, $2, lhs parseState) }
    | HASH_PAREN macro_body_list RPAREN { SynMacroBody.List(SynListKind.HashParen, $2, lhs parseState) }
    | HASH_BRACKET macro_body_list RBRACKET { SynMacroBody.List(SynListKind.AttributeList, $2, lhs parseState) }
    | DOT { SynMacroBody.Trivia(SynMacroTriviaKind.Dot, lhs parseState) }
    | COMMA { SynMacroBody.Trivia(SynMacroTriviaKind.Comma, lhs parseState) }
    | COLON { SynMacroBody.Trivia(SynMacroTriviaKind.Colon, lhs parseState) }
    | BAR { SynMacroBody.Trivia(SynMacroTriviaKind.Bar, lhs parseState) }
    | keyword { SynMacroBody.Keyword($1) }
    | symbol {
        let text = $1
        let symText = (Syntax.textOfSymbol text)
        if (symText = "_") then
            SynMacroBody.Discard (lhs parseState)
        else if (symText = "...") then
            SynMacroBody.Ellipsis (lhs parseState)
        else
            SynMacroBody.Symbol (text) }

cons_expr:
    | CONS expr expr
        { SynExpr.Cons($2, $3, lhs parseState)}
    | CONS expr
        { SynExpr.Cons($2, Syntax.parserRecoveryExpr (lhs parseState), lhs parseState)}
    | CONS
        { SynExpr.Cons(Syntax.parserRecoveryExpr (lhs parseState), Syntax.parserRecoveryExpr (lhs parseState), lhs parseState)}

concat_expr:
    | CONCAT expr expr
        { SynExpr.Concat($2, $3, lhs parseState)}
    | CONCAT expr
        { SynExpr.Concat($2, Syntax.parserRecoveryExpr (lhs parseState), lhs parseState)}
    | CONCAT
        { SynExpr.Concat(Syntax.parserRecoveryExpr (lhs parseState), Syntax.parserRecoveryExpr (lhs parseState), lhs parseState)}

new_expr:
    | NEW syntype_ident
        { SynExpr.New($2, [], lhs parseState) }
    | NEW syntype_ident expr_list
        { SynExpr.New($2, $3, lhs parseState) }

threadable_list: rev_threadable_list { List.rev $1 }
rev_threadable_list:
    | threadable { [$1] }
    | rev_threadable_list threadable { $2 :: $1 }

threadable:
    | prop_plus
        { SynThreadable.Property($1, lhs parseState) }
    | dot_method
        { SynThreadable.Method($1, DotMethodKind.Tuple, lhs parseState) }
    | apply_method
        { SynThreadable.Method($1, DotMethodKind.Apply, lhs parseState) }
    | DOT_BRACKET expr RBRACKET
        { SynThreadable.Index($2, lhs parseState) }
    | expr
        { SynThreadable.Expr($1, lhs parseState) }

prop_plus:
    | PROP_PLUS
        {
          let text = ($1).TrimStart('+')
          SynSymbol(Ident(text, rhs parseState 1))
        }

dot_expr:
    | DOT_BRACKET expr RBRACKET expr
        { SynExpr.DotIndex($4, $2, lhs parseState)}
    | DOT_PLUS symbol expr
        { SynExpr.DotProperty($3, $2, lhs parseState)}
    | prop_plus expr
        { SynExpr.DotProperty($2, $1, lhs parseState)}
    | dot_method expr expr_list
        { SynExpr.DotMethod($2, $1, $3, DotMethodKind.Tuple, lhs parseState) }
    | dot_method expr
        { SynExpr.DotMethod($2, $1, [], DotMethodKind.Tuple, lhs parseState) }
    | apply_method expr expr_list
        { SynExpr.DotMethod($2, $1, $3, DotMethodKind.Apply, lhs parseState) }
    | apply_method expr
        { SynExpr.DotMethod($2, $1, [], DotMethodKind.Apply, lhs parseState) }
    | DOT expr symbol
        {
          let text = Syntax.textOfSymbol $3
          if text.StartsWith('+') then
            SynExpr.DotProperty($2, ($3).trimStart '+', lhs parseState)
          else
            SynExpr.DotMethod($2, $3, [], DotMethodKind.Tuple, lhs parseState) }
    | DOT expr prop_plus
        { SynExpr.DotProperty($2, $3, lhs parseState) }

    | DOT expr DOT_BRACKET expr RBRACKET
        { SynExpr.DotIndex($2, $4, lhs parseState) }
    | DOT expr symbol expr_list
        { SynExpr.DotMethod($2, $3, $4, DotMethodKind.Tuple, lhs parseState) }

lparen_or_lbracket:
    | LPAREN { () }
    | LBRACKET { () }

rparen_or_rbracket:
    | RPAREN { () }
    | RBRACKET { () }

list_expr:
    | BANG_LIST { SynExpr.List([], lhs parseState)}
    | BANG_LIST expr_list { SynExpr.List($2, lhs parseState)}

for_in_expr:
    | FOR_IN lparen_or_lbracket name expr rparen_or_rbracket expr_list
        { SynExpr.ForIn($3, $4, $6, lhs parseState) }

range_expr:
    | BANG_RANGE expr DOTDOT expr DOTDOT expr
        { SynExpr.RangeExpr ($2, Some($4), $6, lhs parseState) }
    | BANG_RANGE expr expr expr
        { SynExpr.RangeExpr ($2, Some($3), $4, lhs parseState) }
    | BANG_RANGE expr DOTDOT expr
        { SynExpr.RangeExpr ($2, None, $4, lhs parseState) }
    | BANG_RANGE expr expr
        { SynExpr.RangeExpr ($2, None, $3, lhs parseState) }
    | expr DOTDOT expr DOTDOT expr
        { SynExpr.RangeExpr ($1, Some($3), $5, lhs parseState) }
    | expr DOTDOT expr
        { SynExpr.RangeExpr ($1, None, $3, lhs parseState) }

if_expr:
    | IF_KW expr expr
        { SynExpr.If($2, $3, None, lhs parseState) }
    | IF_KW expr expr expr
        { SynExpr.If($2, $3, Some $4, lhs parseState) }

quoted_exprs: rev_quoted_exprs { List.rev $1 }
rev_quoted_exprs:
    | quoted_expr { [$1] }
    | rev_quoted_exprs quoted_expr { $2 :: $1 }

quoted_expr:
    | constant { SynQuoted.Const(fst $1, snd $1) }
    | symbol { SynQuoted.Symbol($1) }
    | keyword { SynQuoted.Keyword($1) }
    | LPAREN quoted_exprs RPAREN
        { SynQuoted.List ($2, lhs parseState) }
    | LBRACKET quoted_exprs RBRACKET
        { SynQuoted.Vector ($2, lhs parseState) }
    | LBRACE quoted_exprs RBRACE
        { SynQuoted.HashMap ($2, lhs parseState) }
    | HASH_BRACE quoted_exprs RBRACE
        { SynQuoted.HashSet ($2, lhs parseState) }

value_exprs: rev_value_exprs { List.rev $1 }
rev_value_exprs:
    | { [] }
    | value_expr { [$1] }
    | rev_value_exprs value_expr { $2 :: $1 }

value_expr:
    | constant { SynValue.Const(fst $1, snd $1) }
    | symbol { SynValue.Symbol($1) }
    | keyword { SynValue.Keyword($1) }
    | LPAREN value_exprs RPAREN
        { SynValue.List ($2, lhs parseState) }
    | LBRACKET value_exprs RBRACKET
        { SynValue.Vector ($2, lhs parseState) }
    | LBRACE value_exprs RBRACE
        { SynValue.HashMap ($2, lhs parseState) }
    | HASH_BRACE value_exprs RBRACE
        { SynValue.HashSet ($2, lhs parseState) }

quasiquoted_exprs: rev_quasiquoted_exprs { List.rev $1 }
rev_quasiquoted_exprs:
    | quasiquoted_expr { [$1] }
    | rev_quasiquoted_exprs quasiquoted_expr { $2 :: $1 }

quasiquoted_expr:
    | constant { SynQuasiquote.Const(fst $1, snd $1) }
    | symbol { SynQuasiquote.Symbol($1) }
    | keyword { SynQuasiquote.Keyword($1) }
    | operators { SynQuasiquote.Op($1) }
    | unquote { $1 }
    | splice_unquote { $1 }
    | LPAREN quasiquoted_exprs RPAREN
        { SynQuasiquote.List ($2, lhs parseState) }

unquote:
    | LPAREN UNQUOTE_KW expr RPAREN
        { SynQuasiquote.Unquote ($3, lhs parseState)}

splice_unquote:
    | LPAREN SPLICE_UNQUOTE_KW expr RPAREN
        { SynQuasiquote.SpliceUnquote ($3, lhs parseState)}

operators:
    | LPAREN operators_not_in_parens RPAREN { $2 }

operators_not_in_parens:
    | OP_PLUS
        { SynOp.Plus([], lhs parseState)}
    | OP_MULT
        { SynOp.Mult([], lhs parseState)}
    | OP_PLUS expr_list
        { SynOp.Plus($2, lhs parseState)}
    | OP_MULT expr_list
        { SynOp.Mult($2, lhs parseState)}
    | OP_MINUS expr_list
        { SynOp.Minus($2, lhs parseState)}
    | OP_DIV expr_list
        { SynOp.Div($2, lhs parseState)}

set:
    | SET expr expr
        { SynExpr.Set($2, $3, lhs parseState) }
    // TODO: Report error
    | SET expr
        { let r = lhs parseState
          SynExpr.Set($2, Syntax.parserRecoveryExpr r, r) }
    // TODO
    | SET
        { let r = lhs parseState
          SynExpr.Set(Syntax.parserRecoveryExpr r, Syntax.parserRecoveryExpr r, r) }

let:
    | LET name expr
        { SynExpr.SimpleLet($2, $3, lhs parseState) }
    // TODO: Report error
    | LET name
        { let r = lhs parseState
          SynExpr.SimpleLet($2, Syntax.parserRecoveryExpr r, r) }
    // TODO: Report error
    | LET
        { let r = lhs parseState
          SynExpr.SimpleLet(Syntax.parserRecoveryName r, Syntax.parserRecoveryExpr r, r) }

mut:
    | MUT name expr
        { SynExpr.SimpleMut($2, $3, lhs parseState) }
    // TODO: Report error
    | MUT name
        { let r = lhs parseState
          SynExpr.SimpleMut($2, Syntax.parserRecoveryExpr r, r) }
    // TODO: Report error
    | MUT
        { let r = lhs parseState
          SynExpr.SimpleMut(Syntax.parserRecoveryName r, Syntax.parserRecoveryExpr r, r) }

letstar:
    | LETSTAR binding_list_start expr_list
        { SynExpr.LetStar($2, $3, lhs parseState) }

type_expr:
    | TYPE symbol syntype_ident
        { SynExpr.TypeAlias($2, $3, lhs parseState) }
    | TYPE symbol name_list_start member_list_start
        { SynExpr.Type($2, $3, $4, [], lhs parseState) }
    | attribute_list TYPE symbol name_list_start member_list_start
        { SynExpr.Type($3, $4, $5, $1, lhs parseState) }

record_expr:
    // | RECORD symbol typed_list record_members %prec prec_record_with_members
    //     { SynExpr.Record($2, $3, $4, [], lhs parseState) }
    // | attribute_list RECORD symbol typed_list record_members %prec prec_record_with_members
    //     { SynExpr.Record($3, $4, $5, $1, lhs parseState) }
    // | RECORD symbol typed_list
    //     { SynExpr.Record($2, $3, [], [], lhs parseState) }
    // | attribute_list RECORD symbol typed_list
    //     { SynExpr.Record($3, $4, [], $1, lhs parseState) }
    | RECORD symbol record_labels_or_members
        {
            let labels, members = Syntax.partitionMembers $3
            SynExpr.Record($2, labels, members, [] , lhs parseState)
        }
    | attribute_list RECORD symbol record_labels_or_members
        {
            let labels, members = Syntax.partitionMembers $4
            SynExpr.Record($3, labels, members, $1 , lhs parseState)
        }

record_labels_or_members: rev_record_labels_or_members { List.rev $1 }
rev_record_labels_or_members:
    | record_label_or_member_parens { [$1] }
    | rev_record_labels_or_members record_label_or_member_parens { $2 :: $1 }

record_label_or_member_parens:
    | LPAREN record_label_or_member RPAREN { $2 }
    | LBRACKET record_label_or_member RBRACKET { $2 }

record_label_or_member:
    | MEMBER symbol expr
        { RecordContent.Member(SynTypeMember.Member($2, $3, lhs parseState)) }
    | MEMBER FN symbol arg_list_start expr_list
        { RecordContent.Member(SynTypeMember.MemberFn($3, $4, $5, (lhs parseState))) }
    | symbol COLON syntype_ident
        { RecordContent.Label (RecordLabel(RecordLabelKind.Default, $1, $3, lhs parseState)) }
    | MUT symbol COLON syntype_ident
        { RecordContent.Label (RecordLabel(RecordLabelKind.Mutable, $2, $4, lhs parseState)) }

typed_list: rev_typed_list { List.rev $1 }
rev_typed_list:
    | error { [] }
    | syntyped %prec prec_syntyped { [$1] }
    | rev_typed_list syntyped %prec prec_syntyped { $2 :: $1 }

syntyped:
    | LPAREN symbol COLON syntype_ident RPAREN
        { SynTyped($2, $4, lhs parseState )}
    | LBRACKET symbol COLON syntype_ident RBRACKET
        { SynTyped($2, $4, lhs parseState )}

record_members:
    | LPAREN MEMBERS member_list_start RPAREN { $3 }

record_init_expr:
    | RINIT record_init_list { SynExpr.RecordInit($2, lhs parseState) }

record_init_list: rev_record_init_list { List.rev $1 }
rev_record_init_list:
    | record_init_parens { [$1] }
    | rev_record_init_list record_init_parens { $2 :: $1 }

record_init_parens:
    | LPAREN record_init RPAREN {
        let s, e = $2
        SynInit(s, e, lhs parseState)
     }
    | LBRACKET record_init RBRACKET {
        let s, e = $2
        SynInit(s, e, lhs parseState)
    }

record_init:
    | symbol expr { ($1, $2) }

attribute_list: rev_attribute_list { List.rev $1 }
rev_attribute_list:
    | attr_list { [$1] }
    | rev_attribute_list attr_list { $2 :: $1 }

attr_list:
    | HASH_BRACKET attributes RBRACKET
        { { Attributes = $2; Range = (lhs parseState) } }

attributes: rev_attributes { List.rev $1 }
rev_attributes:
    | attribute %prec prec_attribute { [$1] }
    | rev_attributes BAR attribute %prec prec_attribute_comma { $3 :: $1 }
    | rev_attributes DOT attribute { $3 :: $1 }

attribute:
    | syntype_ident expr
        { { TypeName = $1; ArgExpr = $2; Range = lhs parseState } }
    | syntype_ident
        { { TypeName = $1; ArgExpr = Syntax.UnitExpr <| lhs parseState; Range = lhs parseState } }

member_list_start:
    | { [] }
    | member_list { $1 }

member_list: rev_member_list { List.rev $1 }
rev_member_list:
    | member %prec prec_member { [$1] }
    | rev_member_list member { $2 :: $1 }

member:
    | LPAREN member_in_parens RPAREN { $2 }

member_in_parens:
    | LET name expr
        { SynTypeMember.Let($2, $3, lhs parseState) }
    | MUT name expr
        { SynTypeMember.Mut($2, $3, lhs parseState) }
    | MEMBER symbol expr
        { SynTypeMember.Member($2, $3, lhs parseState) }
    | MEMBERFN symbol arg_list_start expr_list
        { SynTypeMember.MemberFn($2, $3, $4, (lhs parseState)) }
    | MEMBER FN symbol arg_list_start expr_list
        { SynTypeMember.MemberFn($3, $4, $5, (lhs parseState)) }
    | OVERRIDE symbol expr
        { SynTypeMember.OverrideMember($2, $3, lhs parseState) }
    | OVERRIDE FN symbol arg_list_start expr_list
        { SynTypeMember.OverrideFn($3, $4, $5, (lhs parseState)) }

tok_lparen:
    | LPAREN { () }

empty_bindings:
    | LPAREN RPAREN { [] }
    | LBRACKET RBRACKET { [] }

binding_list_start:
    | empty_bindings { $1 }
    | LPAREN binding_list RPAREN { $2 }
    | LBRACKET binding_list RBRACKET { $2 }

binding_list: rev_binding_list { List.rev $1 }
rev_binding_list:
    | binding %prec prec_binding { [$1] }
    | rev_binding_list binding { $2 :: $1 }

binding:
    | name expr { SynBinding($1, $2, lhs parseState) }

name:
    | symbol { SynName.Inferred($1, lhs parseState) }
    | name_in_parens_or_brackets_start { $1 }

name_in_parens_or_brackets_start:
    | LPAREN name_in_parens_or_brackets RPAREN { $2 }
    | LBRACKET name_in_parens_or_brackets RBRACKET { $2 }

name_in_parens_or_brackets:
    | symbol COLON syntype_ident
        { SynName.Typed($1, $3, lhs parseState) }
    | symbol
        { SynName.Inferred($1, lhs parseState) }

empty_name_list:
    | LPAREN RPAREN { [] }
    | LBRACKET RBRACKET { [] }

name_list_start:
    | empty_name_list { $1 }
    | LPAREN name_list RPAREN { $2 }
    | LBRACKET name_list RBRACKET { $2 }

name_list: rev_name_list { List.rev $1 }
rev_name_list:
    | name %prec prec_name { [$1] }
    | rev_name_list name { $2 :: $1 }

symbol:
    | SYMBOL
        { let text = $1
          SynSymbol(Ident(text, lhs parseState))
        }

macro_name:
    | MACRO_NAME
        { let text = $1
          SynSymbol(Ident(text, lhs parseState))
        }

dot_method:
    | DOT_METHOD
        { let text = $1
          SynSymbol(Ident(text.TrimStart '.', lhs parseState))
        }

apply_method:
    | APPLY_METHOD
        { let text = $1
          SynSymbol(Ident(text.TrimStart '-', lhs parseState))
        }

keyword:
    | KEYWORD
        { let text = $1
          SynKeyword(Ident(text, lhs parseState))
        }

syn_comma:
    | COMMA %prec prec_syn_comma { () }

raw_syntype_ident_text:
    | SYMBOL %prec prec_syn_type { $1 }

raw_syntype_ident:
    | SYMBOL %prec prec_syn_type
        { let text = $1
          SynType.Ident(Ident(text, lhs parseState))
        }

syntype_ident:
    | raw_syntype_ident_text { SynType.Ident(Ident($1, lhs parseState))}
    | QUOTE_SYM raw_syntype_ident_text
        { let text = $2
          SynType.Ident(Ident("'" + text, lhs parseState))
        }
    | raw_syntype_ident_text COMMA syntype_comma_list
        {
            let text = $1
            let rest = $3
            SynType.Ident(Ident(text + "," + (String.concat "," rest), lhs parseState))
        }
    // | SYMBOL syn_comma SYMBOL
    //     { let text1 = $1
    //       let text2 = $3
    //       // SynType.Ident(Ident("'xxx" + text1, lhs parseState))
    //       SynType.Ident(Ident(text1 + "," + text2, lhs parseState))
    //     }
    // | QUOTE_SYM SYMBOL
    //     { let text = $2
    //       SynType.Ident(Ident("'" + text, lhs parseState))
    //     }

syntype_comma_list: rev_syntype_comma_list { List.rev $1 }
rev_syntype_comma_list:
    | raw_syntype_ident_text %prec prec_syn_type { [$1] }
    | rev_syntype_comma_list COMMA SYMBOL %prec prec_syn_comma { $3 :: $1 }

constant:
    | rawConstant { ($1, (rhs parseState 1))}

rawConstant:
    | STRING
        { let (raw, kind, _) = $1
          SynConst.String(raw, kind, (lhs parseState))}
    | DECIMAL { SynConst.Decimal($1)}
    | INT32 { SynConst.Int32($1)}
    | INT64 { SynConst.Int64($1)}
    | TRUE { SynConst.Bool(true)}
    | FALSE { SynConst.Bool(false)}
    | NIL { SynConst.Nil }
    | UNIT { SynConst.Unit }
    | CHAR
        { let text = $1
          SynConst.Char(parseChar text) }

function_def:
    | FN symbol arg_list_start expr_list %prec prec_fn
        { SynExpr.FunctionDef($2, FunctionFlags.None, $3, $4, (lhs parseState)) }
    | FN INLINE symbol arg_list_start expr_list %prec prec_fn
        { SynExpr.FunctionDef($3, FunctionFlags.Inline, $4, $5, (lhs parseState)) }
    | FN REC INLINE symbol arg_list_start expr_list %prec prec_fn
        { SynExpr.FunctionDef($4, FunctionFlags.Recursive ||| FunctionFlags.Inline, $5, $6, (lhs parseState)) }
    | FN REC symbol arg_list_start expr_list %prec prec_fn
        { SynExpr.FunctionDef($3, FunctionFlags.Recursive, $4, $5, (lhs parseState)) }
    | FN arg_list_start expr_list %prec prec_lambda_def
        { SynExpr.LambdaDef(SynLambda($2, $3, (lhs parseState))) }
    | FNSTAR arg_list_start expr_list
        { SynExpr.LambdaDef(SynLambda($2, $3, (lhs parseState))) }
    | invalid_function_def %prec prec_invalid_fn { $1 }

invalid_function_def:
    // TODO: Report
    | FN %prec prec_invalid_fn
        { SynExpr.LambdaDef(SynLambda([], [], (lhs parseState))) }
    // TODO: Report
    | FN symbol %prec prec_invalid_fn
        { SynExpr.FunctionDef($2, FunctionFlags.None, [], [], lhs parseState) }
    // TODO: Report
    | FN arg_list_start %prec prec_invalid_fn
        { SynExpr.LambdaDef(SynLambda([], [], (lhs parseState))) }
    // TODO: Report
    | FN symbol arg_list_start %prec prec_invalid_fn
        { SynExpr.FunctionDef($2, FunctionFlags.None, $3, [], (lhs parseState)) }
    | FN INLINE symbol arg_list_start %prec prec_invalid_fn
        { SynExpr.FunctionDef($3, FunctionFlags.Inline, $4, [], (lhs parseState)) }

macro_def:
    | MACRO symbol arg_list_start expr_list
        { SynExpr.MacroDef($2, $3, $4, (lhs parseState)) }

arg_list_start:
    | UNIT { [] }
    | LPAREN RPAREN { [] }
    | LBRACKET RBRACKET { [] }
    | lparen_or_lbracket arg_list rparen_or_rbracket { $2 }
    | lparen_or_lbracket recover %prec prec_recover { [] }
    | recover %prec prec_recover { [] }

arg_list: rev_arg_list { List.rev $1 }
rev_arg_list:
    | arg %prec prec_arg { [$1] }
    | rev_arg_list arg { $2 :: $1 }

arg:
    | symbol { SynArg.InferredArg($1, lhs parseState) }
    | arg_in_parens_or_brackets_start { $1 }

arg_in_parens_or_brackets_start:
    | LPAREN arg_in_parens_or_brackets RPAREN { $2 }
    | LBRACKET arg_in_parens_or_brackets RBRACKET { $2 }

arg_in_parens_or_brackets:
    | symbol COLON syntype_ident
        { SynArg.TypedArg($1, $3, lhs parseState) }
    | symbol
        { SynArg.InferredArg($1, lhs parseState) }

function_call:
    | expr expr_list { SynExpr.FunctionCall($1, $2, (lhs parseState))}
    | expr { SynExpr.FunctionCall($1, [], (lhs parseState))}

function_call_args:
    | empty_call_args { $1 }
    | expr_list { $1 }

empty_call_args:
    | { [] }

match_expr:
    | MATCH expr match_list
        { SynExpr.Match ($2, $3, lhs parseState)}
    // TODO: report
    | MATCH expr
        { let r = lhs parseState;
          SynExpr.Match ($2, [], r)}
    // TODO: report
    | MATCH
        { let r = lhs parseState;
          SynExpr.Match (Syntax.parserRecoveryExpr r, [], r)}

match_list: rev_match_list { List.rev $1 }
rev_match_list:
    | match_start { [$1] }
    | rev_match_list match_start { $2 :: $1 }

match_start:
    | lparen_or_lbracket match rparen_or_rbracket { $2 }
    // TODO: report
    | lparen_or_lbracket rparen_or_rbracket {
        Syntax.parserRecoveryMatch (lhs parseState)
     }

match:
    | match_pattern expr_list
        { SynMatch.SynMatch($1, None, $2, lhs parseState) }

    | match_pattern LPAREN WHEN expr RPAREN expr_list
        { SynMatch.SynMatch($1, Some($4), $6, lhs parseState) }

match_tuple_list: rev_match_tuple_list %prec prec_match_tuple_list { List.rev $1 }
rev_match_tuple_list:
    | match_pattern %prec prec_match_pattern { [$1] }
    | rev_match_tuple_list COMMA match_pattern %prec prec_match_tuple_list { $3 :: (SynMatchPattern.CommaOrDot (rhs parseState 2)) :: $1 }
    | rev_match_tuple_list DOT match_pattern %prec prec_match_tuple_list { $3 :: (SynMatchPattern.CommaOrDot (rhs parseState 2)) :: $1 }
    | rev_match_tuple_list match_pattern %prec prec_match_tuple_list { $2 :: $1 }

match_pattern:
    | constant %prec prec_match_pattern_const { SynMatchPattern.Const(fst $1, snd $1) }
    | symbol {
        let text = $1
        if ((Syntax.textOfSymbol text) = "_") then
            SynMatchPattern.Discard (lhs parseState)
        else
            SynMatchPattern.Symbol (text, lhs parseState) }
    | LPAREN BANG_TUPLE match_tuple_list RPAREN
        { SynMatchPattern.Tuple (Syntax.withoutCommaOrDots $3, lhs parseState) }
    | LPAREN match_tuple_list RPAREN
        {
            let items = $2
            let without = Syntax.withoutCommaOrDots items
            if items.Length <> without.Length then
                SynMatchPattern.Tuple (without, lhs parseState)
            else
                SynMatchPattern.List (without, lhs parseState)
        }
