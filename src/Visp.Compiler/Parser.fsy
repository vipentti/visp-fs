// FsYacc parser
%{
// Copyright 2023 Ville Penttinen
// Distributed under the MIT License.
// https://github.com/vipentti/visp-fs/blob/main/LICENSE.md

#nowarn "1182"  // generated code has lots of unused "parseState"

open Visp.Compiler.DiagnosticsLogger
open Visp.Compiler.StringResources
open Visp.Compiler.Syntax
open Visp.Compiler.ParseHelpers
open Visp.Runtime.Library
open FSharp.Text.Parsing

// This function is called by the generated parser code. Returning initiates error recovery
// It must be called precisely "parse_error_rich"
let parse_error_rich = Some(fun (ctxt: ParseErrorContext<_>) ->
    raise (SyntaxError(box ctxt, (lhs ctxt.ParseState))))


let mkRecoveryPat s = Syntax.parserRecoveryPat (lhs s)

%}

%start start
%start raw_expr
%start raw_macro_body

%token EOF
%token LPAREN RPAREN
%token LBRACKET RBRACKET
%token LBRACE RBRACE HASH_BRACE HASH_PAREN HASH_BRACKET BRACE_BAR BAR_BRACE PAREN_BAR BAR_PAREN BRACKET_BAR BAR_BRACKET
%token TRUE FALSE NIL COLON COLON_COLON COMMA UNIT BAR COLON_GREATER
%token OP_PLUS OP_MINUS OP_MULT OP_DIV QUOTE_SYM OP_GREATER OP_LESS COLON_QMARK EQUALS AMP_AMP BAR_BAR GREATER_EQUALS LESS_EQUALS GREATER_GREATER BANG_EQUALS
%token BANG_RANGE FOR_IN FOR_TO BANG_LIST BANG_MAP BANG_SET BANG_ARRAY BANG_VEC BANG_TUPLE
%token DOTDOT
%token AT
%token OPEN MODULE
%token FN FNSTAR LET USE LET_BANG USE_BANG DO_BANG LETSTAR MUT SET DOT NEW DOT_BRACKET DOT_PLUS IF_KW BEGIN_KW DO_KW QUOTE_KW UNQUOTE_KW SPLICE_UNQUOTE_KW QUASIQUOTE_KW
%token ATOM_KW DEREF_KW WHILE TYPE TYPEALIAS INTERFACE RECORD MEMBER MEMBERS MEMBERFN MEMBER_GET MEMBER_SET OVERRIDE MACRO MATCH WHEN REQUIRE
%token THREAD_FIRST THREAD_LAST SYNTAX_MACRO SEQ UNION
%token INLINE REC RINIT
%token <bool> YIELD
%token <bool> RETURN

/* bool indicates if INT8 was 'bad' max_int+1, e.g. '128' */
%token <sbyte * bool> INT8
%token <int16 * bool> INT16
%token <int32 * bool> INT32 INT32_DOT_DOT
%token <int64 * bool> INT64
%token <int64 * bool> NATIVEINT

// only during lexing
%token <token list> TOKENLIST

%token <byte> UINT8
%token <uint16> UINT16
%token <uint32> UINT32
%token <uint64> UINT64
%token <uint64> UNATIVEINT
%token <single> IEEE32
%token <double> IEEE64
%token <System.Decimal> DECIMAL

%token <string> HASH_IDENT
%token <string> PROP_PLUS
%token <string> MACRO_NAME
%token <string> CHAR
%token <string * SynStringKind * ParseHelpers.LexerContinuation> STRING
%token <string> SYMBOL KEYWORD RAWSTRING DOT_METHOD APPLY_METHOD

// %left TRUE FALSE
// %left LPAREN LBRACKET
// %nonassoc RPAREN RBRACKET
%nonassoc prec_module_decl

%nonassoc prec_module_decls
%nonassoc prec_hash_ident_args
%nonassoc prec_hash_ident

// https://github.com/dotnet/fsharp/blob/363e8768ecd3e537aff643e0ea6da89115f249c2/src/Compiler/pars.fsy#L189

%nonassoc prec_coll_open prec_coll_close

%nonassoc QUOTE_SYM
%nonassoc LPAREN HASH_PAREN PAREN_BAR
%nonassoc LBRACKET BRACKET_BAR
%nonassoc LBRACE HASH_BRACE BRACE_BAR
%nonassoc HASH_BRACKET
%nonassoc RPAREN BAR_PAREN
%nonassoc RBRACKET BAR_BRACKET
%nonassoc RBRACE BAR_BRACE
%nonassoc AT
%nonassoc BANG_TUPLE

%nonassoc OPEN MODULE
%nonassoc prec_constant

%nonassoc prec_vector
%nonassoc prec_at_expr
%nonassoc prec_expr
%nonassoc prec_new_exprs
%nonassoc prec_new_no_exprs

%nonassoc INT8 INT16 INT32 INT64 NATIVEINT UINT8 UINT16 UINT32 UINT64 UNATIVEINT IEEE32 IEEE64 DECIMAL
%nonassoc TRUE FALSE NIL SYMBOL KEYWORD RAWSTRING DOT_METHOD APPLY_METHOD STRING UNIT CHAR
%nonassoc HASH_IDENT
%nonassoc prec_symbol
%nonassoc prec_name_list
%nonassoc prec_syn_type_paren_op

%nonassoc prec_type_expr
%nonassoc prec_type_pat

%nonassoc prec_syn_type_paren
%nonassoc prec_syn_type_mult
%nonassoc prec_syn_type_generic
%nonassoc prec_syn_type_array
%nonassoc prec_syn_pat
%nonassoc prec_syn_pat_open
%nonassoc prec_syn_type_open

%nonassoc OP_LESS OP_GREATER THREAD_FIRST

%nonassoc OP_MULT
%nonassoc COLON

// %left COMMA
// %right COMMA
%nonassoc prec_syn_type
%nonassoc prec_syn_type_commas
%nonassoc prec_attribute

%nonassoc prec_attribute_comma

%nonassoc prec_union_field

%nonassoc prec_dot_no_paren
%nonassoc prec_paren
%nonassoc prec_bracket

%nonassoc prec_binding prec_member
%nonassoc prec_arg prec_name

%nonassoc prec_binding_empty
%nonassoc binding_list_empty

%nonassoc prec_fn
%nonassoc prec_invalid_fn
%nonassoc prec_lambda
%nonassoc prec_call
%nonassoc prec_paren_expr
%nonassoc prec_lambda_def_call
%nonassoc prec_lambda_def
%nonassoc prec_normal_tuple
%nonassoc prec_match_pattern_const
%nonassoc prec_match_pattern
%nonassoc prec_match
%nonassoc prec_match_tuple_list

%nonassoc prec_colon_colon
%nonassoc prec_syntyped
%nonassoc prec_record_with_members

%nonassoc prec_record_expr_only
%nonassoc prec_record_init

%nonassoc prec_recover
// %nonassoc EOF

%nonassoc prec_eof

%nonassoc prec_error
%nonassoc EOF

%type <ParsedFile> start
%type <SynExpr> raw_expr
%type <SynMacroBody> raw_macro_body

%%

//  start of actual code
start: prog { $1 }

raw_expr: expr { $1 }

raw_macro_body: macro_body { $1 }

prog:
    | file_fragments
        { ParsedFile($1) }

file_fragments: rev_file_fragments { List.rev $1 }
rev_file_fragments:
    | file_fragment { [$1] }
    | rev_file_fragments file_fragment { $2 :: $1 }

file_fragment:
    | module_decls
        { ParsedFileFragment.AnonModule($1, lhs parseState)}

    // TODO: If this uses recover interesting things happen
    | error EOF %prec prec_error
        { ParsedFileFragment.AnonModule([], lhs parseState) }

module_decls: rev_module_decls %prec prec_module_decls { List.rev $1 }
rev_module_decls:
    | module_decl %prec prec_module_decl { [$1] }
    | rev_module_decls module_decl %prec prec_module_decls { $2 :: $1 }

module_decl:
    | HASH_IDENT hash_ident_args %prec prec_hash_ident
        { SynModuleDecl.HashDirective(ParsedHashDirective($1, $2, lhs parseState), lhs parseState)}
    | module_parens { $1 }
    | expr { SynModuleDecl.Expr($1, lhs parseState) }

hash_ident_args: rev_hash_ident_args %prec prec_hash_ident_args { List.rev $1 }
rev_hash_ident_args:
    | %prec prec_hash_ident_args { [] }
    | hash_ident_arg %prec prec_hash_ident { [$1] }
    | rev_hash_ident_args hash_ident_arg %prec prec_hash_ident_args { $2 :: $1 }

hash_ident_arg:
    | STRING %prec prec_hash_ident {
        let (raw, k, _) = $1
        ParsedHashDirectiveArgument.String(raw, k, rhs parseState 1)
    }

module_parens:
    | LPAREN module_help RPAREN { $2 }

module_help:
    | OPEN symbol
        { SynModuleDecl.Open($2, lhs parseState) }
    | MODULE symbol module_decls
        { SynModuleDecl.NestedModule($2, $3, lhs parseState) }
    | REQUIRE symbol STRING
        { let (raw, _, _) = $3
          SynModuleDecl.Require($2, raw, lhs parseState) }

syn_symbol:
    | SYMBOL {Syntax.mkSynSymbol $1 (rhs parseState 1)}

symbol:
    | SYMBOL { SynSymbol(Ident($1, lhs parseState)) }

expr_list: rev_expr_list { List.rev $1 }
rev_expr_list:
    | expr %prec prec_expr { [$1] }
    | rev_expr_list expr { $2 :: $1 }

expr_list_or_empty:
    | { [] }
    | expr_list { $1 }

recover:
   | error %prec prec_error { true }
   | EOF { false }

symbol_with_ops:
    | SYMBOL { Syntax.mkSynSymbol $1 (rhs parseState 1) }
    | SYMBOL OP_GREATER SYMBOL { Syntax.mkSynSymbol $"{$1}>{$3}" (rhs2 parseState 1 3) }
    | SYMBOL OP_LESS SYMBOL OP_GREATER { Syntax.mkSynSymbol $"{$1}<{$3}>" (rhs2 parseState 1 4) }
    | SYMBOL OP_GREATER { Syntax.mkSynSymbol $"{$1}>" (rhs2 parseState 1 2) }

expr:
    | constant %prec prec_constant { SynExpr.Const(fst $1, snd $1) }
    | symbol_with_ops { SynExpr.Symbol($1) }
    | keyword { SynExpr.Keyword($1) }
    | AT expr %prec prec_at_expr { SynExpr.Deref(true, $2, lhs parseState) }
    | QUOTE_SYM quoted_expr %prec prec_at_expr
        { SynExpr.Quote(true, $2, lhs parseState) }
    | LBRACE expr_list_or_empty RBRACE { CollExpr.mkHashMap $2 (lhs parseState)}
    | HASH_BRACE expr_list_or_empty RBRACE { CollExpr.mkHashSet $2 (lhs parseState)}
    | HASH_PAREN lambda_short_expr_list RPAREN
        { SynExpr.LambdaShort($2, lhs parseState)}
    | vector_start %prec prec_expr
        { $1 }

    | brace_bar { $1 }
    | bracket_bar { $1 }
    | paren_bar { $1 }
    | inside_parens %prec prec_paren { $1 }

brace_bar:
    | BRACE_BAR record_init_bar_list BAR_BRACE { SynExpr.RecordInit($2, lhs parseState) }
    | BRACE_BAR record_init_bar_list recover { SynExpr.RecordInit([], lhs parseState) }

bracket_bar:
    | BRACKET_BAR recover { CollExpr.mkFsArray [] (lhs parseState)}
    | BRACKET_BAR BAR_BRACKET { CollExpr.mkFsArray [] (lhs parseState)}
    | BRACKET_BAR expr_list BAR_BRACKET { CollExpr.mkFsArray $2 (lhs parseState)}

paren_bar:
    | PAREN_BAR recover { CollExpr.mkFsList [] (lhs parseState)}
    | PAREN_BAR BAR_PAREN { CollExpr.mkFsList [] (lhs parseState)}
    | PAREN_BAR expr_list BAR_PAREN { CollExpr.mkFsList $2 (lhs parseState)}

lambda_short_expr_list:
    | parens_expr { $1 }

vector_start:
    | LBRACKET RBRACKET %prec prec_vector { CollExpr.mkVector [] (lhs parseState) }
    | LBRACKET expr_list RBRACKET %prec prec_vector { CollExpr.mkVector $2 (lhs parseState) }

inside_parens:
    | LPAREN RPAREN { SynExpr.Const (SynConst.Unit, lhs parseState) }
    | LPAREN parens_expr_start RPAREN { $2 }
    | LPAREN parens_expr_start EOF %prec prec_recover { $2 }
    // TODO: handle this better?
    // | LPAREN parens_expr_start error %prec prec_recover { $2 }
    | LPAREN recover %prec prec_recover {
        Syntax.parserRecoveryExpr (lhs parseState)
    }

parens_expr_start:
    | parens_expr %prec prec_paren_expr { $1 }

dotted_exprs: rev_dotted_exprs { List.rev $1 }
rev_dotted_exprs:
    | { [] }
    | expr { [$1] }
    | rev_dotted_exprs DOT expr { $3 :: $1 }
    | rev_dotted_exprs COMMA expr { $3 :: $1 }

colon_colon_exprs: rev_colon_colon_exprs { List.rev $1 }
rev_colon_colon_exprs:
    | { [] }
    | expr { [$1] }
    | rev_colon_colon_exprs COLON_COLON expr  { $3 :: $1 }

parens_expr:
    | expr DOT dotted_exprs
        { SynExpr.Tuple($1 :: $3, lhs parseState)}
    | expr COMMA dotted_exprs
        { SynExpr.Tuple($1 :: $3, lhs parseState)}
    | expr COLON_COLON colon_colon_exprs
        { CollExpr.mkFsList ($1 :: $3) (lhs parseState)}
    | function_def %prec prec_fn { $1 }
    | function_call %prec prec_call { $1 }
    | let_or_use { $1 }
    | letstar { $1 }
    | set { $1 }
    | if_expr { $1 }
    | type_expr { $1 }
    | record_expr { $1 }
    | union_expr { $1 }
    | for_in_expr { $1 }
    | for_to_expr { $1 }
    | record_init_expr { $1 }
    | range_expr { $1 }
    | list_expr { $1 }
    | match_expr { $1 }
    | new_expr { $1 }
    | operators_not_in_parens { SynExpr.Op($1) }
    | syntax_macro_expr { $1 }
    | macro_call_expr { $1 }
    | QUOTE_KW quoted_expr
        { SynExpr.Quote(false, $2, lhs parseState) }
    | QUASIQUOTE_KW quasiquoted_expr
        { SynExpr.Quasiquote(false, $2, lhs parseState) }
    | BEGIN_KW expr_list
        { SynExpr.Begin($2, BeginKind.Begin, lhs parseState) }
    | DO_KW expr_list
        { SynExpr.Begin($2, BeginKind.Do, lhs parseState) }
    | dot_expr { $1 }
    | ATOM_KW expr
        { SynExpr.Atom($2, lhs parseState) }
    | DEREF_KW expr
        { SynExpr.Deref(false, $2, lhs parseState) }
    | WHILE expr expr_list
        { SynExpr.While($2, $3, lhs parseState) }
    | THREAD_FIRST expr_list
        { SynExpr.ThreadFirst ($2, lhs parseState)}
    | THREAD_LAST threadable_list
        { SynExpr.ThreadLast ($2, lhs parseState)}

    | BANG_TUPLE %prec prec_normal_tuple { SynExpr.Tuple([], lhs parseState)}
    | BANG_TUPLE expr_list %prec prec_normal_tuple { SynExpr.Tuple($2, lhs parseState)}

    | BANG_MAP { CollExpr.mkFsMap [] (lhs parseState)}
    | BANG_MAP expr_list { CollExpr.mkFsMap $2 (lhs parseState)}

    | BANG_SET { CollExpr.mkFsSet [] (lhs parseState)}
    | BANG_SET expr_list { CollExpr.mkFsSet $2 (lhs parseState)}

    | BANG_ARRAY { CollExpr.mkFsArray [] (lhs parseState)}
    | BANG_ARRAY expr_list { CollExpr.mkFsArray $2 (lhs parseState)}

    | BANG_VEC { CollExpr.mkFsVec [] (lhs parseState)}
    | BANG_VEC expr_list { CollExpr.mkFsVec $2 (lhs parseState)}

    | SEQ expr_list { SynExpr.FsSeq($2, lhs parseState) }
    | YIELD expr { SynExpr.FsYield($2, $1, lhs parseState) }
    | RETURN expr { SynExpr.FsReturn($2, $1, lhs parseState) }
    | DO_BANG expr { SynExpr.FsDo($2, true, lhs parseState) }

macro_call_expr:
    | macro_call { SynExpr.SyntaxMacroCall($1) }

macro_call:
    | macro_name
        { let mNameBody = SynMacroBody.Symbol($1)
          SynMacroCall($1, [mNameBody], lhs parseState) }
    | macro_name macro_body_list
        { let mNameBody = SynMacroBody.Symbol($1)
          SynMacroCall($1, mNameBody :: $2, lhs parseState) }

syntax_macro_expr:
    | syntax_macro { SynExpr.SyntaxMacro($1)}

syntax_macro:
    | SYNTAX_MACRO symbol macro_cases
        { SynMacro($2, $3, lhs parseState )}

macro_cases: rev_macro_cases { List.rev $1 }
rev_macro_cases:
    | macro_case_start { [$1] }
    | rev_macro_cases macro_case_start { $2 :: $1 }

macro_case_start:
    | LPAREN macro_case_pat macro_body RPAREN
        { SynMacroCase($2, $3, lhs parseState) }
    | LBRACKET macro_case_pat macro_body RBRACKET
        { SynMacroCase($2, $3, lhs parseState) }

macro_case_pat:
    | LPAREN macro_pat_list RPAREN { $2 }
    | LBRACKET macro_pat_list RBRACKET { $2 }

macro_pat_list: rev_macro_pat_list { List.rev $1 }
rev_macro_pat_list:
    | macro_pat { [$1] }
    | rev_macro_pat_list macro_pat { $2 :: $1 }

macro_pat:
    | constant { SynMacroPat.Const(fst $1, snd $1) }
    | LPAREN macro_pat_list RPAREN { SynMacroPat.List($2, lhs parseState) }
    | LBRACKET macro_pat_list RBRACKET { SynMacroPat.List($2, lhs parseState) }
    | DOT { SynMacroPat.Trivia(SynMacroTriviaKind.Dot, lhs parseState) }
    | COMMA { SynMacroPat.Trivia(SynMacroTriviaKind.Comma, lhs parseState) }
    | COLON { SynMacroPat.Trivia(SynMacroTriviaKind.Colon, lhs parseState) }
    | COLON_COLON { SynMacroPat.Trivia(SynMacroTriviaKind.ColonColon, lhs parseState) }
    | BAR { SynMacroPat.Trivia(SynMacroTriviaKind.Bar, lhs parseState) }
    | symbol {
        let text = $1
        let symText = (Syntax.textOfSymbol text)
        if (symText = "_") then
            SynMacroPat.Discard (lhs parseState)
        else if (symText = "...") then
            SynMacroPat.Ellipsis (lhs parseState)
        else
            SynMacroPat.Symbol (text, lhs parseState) }

macro_body_list: rev_macro_body_list { List.rev $1 }
rev_macro_body_list:
    | macro_body { [$1] }
    | rev_macro_body_list macro_body { $2 :: $1 }

collection_open_kind:
    | LPAREN %prec prec_coll_open { CollectionKind.Paren }
    | LBRACKET %prec prec_coll_open { CollectionKind.Bracket }
    | LBRACE { CollectionKind.Brace }
    | HASH_BRACE { CollectionKind.HashBrace }
    | HASH_BRACKET { CollectionKind.HashBracket }
    | BRACE_BAR { CollectionKind.BraceBar }
    | BRACKET_BAR { CollectionKind.FsArray }
    | PAREN_BAR { CollectionKind.FsList }
    | DOT_BRACKET %prec prec_coll_open { CollectionKind.DotBracket }

macro_open_kind:
    | LPAREN { SynListKind.Paren }
    | LBRACKET { SynListKind.Bracket }
    | LBRACE { SynListKind.Brace }
    | HASH_BRACE { SynListKind.HashBrace }
    | HASH_PAREN { SynListKind.HashParen }
    | HASH_BRACKET { SynListKind.HashBracket }
    | BRACE_BAR { SynListKind.BraceBar }
    | BRACKET_BAR { SynListKind.BracketBar }
    | DOT_BRACKET { SynListKind.DotBracket }
    | PAREN_BAR { SynListKind.ParenBar }

collection_close_kind:
    | RPAREN %prec prec_coll_close { () }
    | RBRACKET %prec prec_coll_close { () }
    | RBRACE { () }
    | BAR_BRACE { () }
    | BAR_BRACKET { () }
    | BAR_PAREN { () }

macro_body:
    | constant { SynMacroBody.Const(fst $1, snd $1) }
    | LPAREN macro_name RPAREN
        { let mNameBody = SynMacroBody.Symbol($2)
          SynMacroBody.Call(SynMacroCall($2, [mNameBody], lhs parseState))}
    | LPAREN macro_name macro_body_list RPAREN
        { let mNameBody = SynMacroBody.Symbol($2)
          SynMacroBody.Call(SynMacroCall($2, mNameBody :: $3, lhs parseState)) }
    | HASH_PAREN macro_name RPAREN
        { let mNameBody = SynMacroBody.Symbol($2)
          SynMacroBody.Call(SynMacroCall($2, [mNameBody], lhs parseState))}
    | HASH_PAREN macro_name macro_body_list RPAREN
        { let mNameBody = SynMacroBody.Symbol($2)
          SynMacroBody.Call(SynMacroCall($2, mNameBody :: $3, lhs parseState)) }

    | macro_open_kind collection_close_kind { SynMacroBody.List($1, [], lhs parseState) }
    | macro_open_kind macro_body_list collection_close_kind { SynMacroBody.List($1, $2, lhs parseState) }

    | DOT { SynMacroBody.Trivia(SynMacroTriviaKind.Dot, lhs parseState) }
    | COMMA { SynMacroBody.Trivia(SynMacroTriviaKind.Comma, lhs parseState) }
    | COLON { SynMacroBody.Trivia(SynMacroTriviaKind.Colon, lhs parseState) }
    | COLON_COLON { SynMacroBody.Trivia(SynMacroTriviaKind.ColonColon, lhs parseState) }
    | BAR { SynMacroBody.Trivia(SynMacroTriviaKind.Bar, lhs parseState) }
    | keyword { SynMacroBody.Keyword($1) }
    | symbol {
        let text = $1
        let symText = (Syntax.textOfSymbol text)
        if (symText = "_") then
            SynMacroBody.Discard (lhs parseState)
        else if (symText = "...") then
            SynMacroBody.Ellipsis (lhs parseState)
        else
            SynMacroBody.Symbol (text) }

new_expr:
    | NEW syn_type_name
        { SynExpr.New($2, [], lhs parseState) }
    | NEW syn_type_name expr_list
        { SynExpr.New($2, $3, lhs parseState) }
    | NEW
        { SynExpr.New(Syntax.parserRecoveryType (lhs parseState), [], lhs parseState) }

threadable_list: rev_threadable_list { List.rev $1 }
rev_threadable_list:
    | threadable { [$1] }
    | rev_threadable_list threadable { $2 :: $1 }

threadable:
    | prop_plus
        { SynThreadable.Property($1, lhs parseState) }
    | dot_method
        { SynThreadable.Method($1, DotMethodKind.Tuple, lhs parseState) }
    | apply_method
        { SynThreadable.Method($1, DotMethodKind.Apply, lhs parseState) }
    | dot_bracket_expr_raw
        { SynThreadable.Index($1, lhs parseState) }
    | expr
        { SynThreadable.Expr($1, lhs parseState) }

prop_plus:
    | PROP_PLUS
        {
          let text = ($1).TrimStart('+')
          SynSymbol(Ident(text, rhs parseState 1))
        }

expr_comma_list: rev_expr_comma_list { List.rev $1 }
rev_expr_comma_list:
    | expr { [$1] }
    | OP_MULT { [(Syntax.mkSynSymbolExpr "*" (rhs parseState 1))] }
    | rev_expr_comma_list COMMA expr { $3 :: $1 }

dot_bracket_expr_raw:
    | DOT_BRACKET expr RBRACKET
        { [$2] }
    | DOT_BRACKET expr COMMA rev_expr_comma_list RBRACKET
        { $2 :: $4 }
    | DOT_BRACKET OP_MULT COMMA rev_expr_comma_list RBRACKET
        { (Syntax.mkSynSymbolExpr "*" (rhs parseState 2)) :: $4 }

dot_expr:
    | dot_bracket_expr_raw expr
        { SynExpr.DotIndex($2, $1, lhs parseState)}
    | dot_bracket_expr_raw recover
        { SynExpr.DotIndex(Syntax.parserRecoveryExpr (lhs parseState), $1, lhs parseState)}
    | DOT_BRACKET expr recover
        { SynExpr.DotIndex(Syntax.parserRecoveryExpr (lhs parseState), [$2], lhs parseState)}
    | DOT_PLUS symbol expr
        { SynExpr.DotProperty($3, $2, lhs parseState)}
    | DOT_PLUS symbol
        { SynExpr.DotProperty(Syntax.parserRecoveryExpr (lhs parseState), $2, lhs parseState)}
    | DOT_PLUS
        { SynExpr.DotProperty(Syntax.parserRecoveryExpr (lhs parseState), Syntax.parserRecoverySymbol (lhs parseState), lhs parseState)}
    | prop_plus expr
        { SynExpr.DotProperty($2, $1, lhs parseState)}
    | prop_plus
        { SynExpr.DotProperty(Syntax.parserRecoveryExpr (lhs parseState), $1, lhs parseState)}
    | dot_method expr expr_list
        { SynExpr.DotMethod($2, $1, $3, DotMethodKind.Tuple, lhs parseState) }
    | dot_method expr
        { SynExpr.DotMethod($2, $1, [], DotMethodKind.Tuple, lhs parseState) }
    | dot_method
        { SynExpr.DotMethod(Syntax.parserRecoveryExpr (lhs parseState), $1, [], DotMethodKind.Tuple, lhs parseState) }
    | apply_method expr expr_list
        { SynExpr.DotMethod($2, $1, $3, DotMethodKind.Apply, lhs parseState) }
    | apply_method expr
        { SynExpr.DotMethod($2, $1, [], DotMethodKind.Apply, lhs parseState) }
    | apply_method
        { SynExpr.DotMethod(Syntax.parserRecoveryExpr (lhs parseState), $1, [], DotMethodKind.Apply, lhs parseState) }
    | DOT expr symbol
        {
          let text = Syntax.textOfSymbol $3
          if text.StartsWith('+') then
            SynExpr.DotProperty($2, ($3).trimStart '+', lhs parseState)
          else
            SynExpr.DotMethod($2, $3, [], DotMethodKind.Tuple, lhs parseState) }
    | DOT expr prop_plus
        { SynExpr.DotProperty($2, $3, lhs parseState) }

    | DOT expr dot_bracket_expr_raw
        { SynExpr.DotIndex($2, $3, lhs parseState) }
    | DOT expr symbol expr_list
        { SynExpr.DotMethod($2, $3, $4, DotMethodKind.Tuple, lhs parseState) }
    | DOT
        { SynExpr.DotMethod(Syntax.parserRecoveryExpr (lhs parseState), Syntax.parserRecoverySymbol (lhs parseState), [], DotMethodKind.Tuple, lhs parseState) }

lparen_or_lbracket:
    | LPAREN { () }
    | LBRACKET { () }

rparen_or_rbracket:
    | RPAREN { () }
    | RBRACKET { () }

list_expr:
    | BANG_LIST { CollExpr.mkFsList [] (lhs parseState)}
    | BANG_LIST expr_list { CollExpr.mkFsList $2 (lhs parseState)}

for_in_expr:
    | FOR_IN lparen_or_lbracket syn_pat expr rparen_or_rbracket expr_list
        { SynExpr.ForIn($3, $4, $6, lhs parseState) }

for_to_expr:
    | FOR_TO lparen_or_lbracket syn_symbol lparen_or_lbracket expr SYMBOL expr rparen_or_rbracket rparen_or_rbracket expr_list
        {
            let down = $6 = "downto"
            SynExpr.ForTo($3, $5, $7, $10, down, lhs parseState)
        }

range_expr:
    | BANG_RANGE expr DOTDOT expr DOTDOT expr
        { SynExpr.RangeExpr ($2, Some($4), $6, lhs parseState) }
    | BANG_RANGE expr expr expr
        { SynExpr.RangeExpr ($2, Some($3), $4, lhs parseState) }
    | BANG_RANGE expr DOTDOT expr
        { SynExpr.RangeExpr ($2, None, $4, lhs parseState) }
    | BANG_RANGE expr expr
        { SynExpr.RangeExpr ($2, None, $3, lhs parseState) }
    | expr DOTDOT expr DOTDOT expr
        { SynExpr.RangeExpr ($1, Some($3), $5, lhs parseState) }
    | expr DOTDOT expr
        { SynExpr.RangeExpr ($1, None, $3, lhs parseState) }

if_expr:
    | IF_KW expr expr
        { SynExpr.If($2, $3, None, lhs parseState) }
    | IF_KW expr expr expr
        { SynExpr.If($2, $3, Some $4, lhs parseState) }

quoted_exprs: rev_quoted_exprs { List.rev $1 }
rev_quoted_exprs:
    | quoted_expr { [$1] }
    | rev_quoted_exprs quoted_expr { $2 :: $1 }

quoted_expr:
    | constant { SynQuoted.Const(fst $1, snd $1) }
    | symbol { SynQuoted.Symbol($1) }
    | keyword { SynQuoted.Keyword($1) }
    | collection_open_kind collection_close_kind
        { SynQuoted.Collection(SynCollection($1, [], lhs parseState)) }
    | collection_open_kind quoted_exprs collection_close_kind
        { SynQuoted.Collection(SynCollection($1, $2, lhs parseState)) }

quasiquoted_exprs: rev_quasiquoted_exprs { List.rev $1 }
rev_quasiquoted_exprs:
    | quasiquoted_expr { [$1] }
    | rev_quasiquoted_exprs quasiquoted_expr { $2 :: $1 }

quasiquoted_expr:
    | constant { SynQuasiquote.Const(fst $1, snd $1) }
    | symbol { SynQuasiquote.Symbol($1) }
    | keyword { SynQuasiquote.Keyword($1) }
    | unquote { $1 }
    | splice_unquote { $1 }
    | collection_open_kind collection_close_kind
        { SynQuasiquote.Collection(SynCollection($1, [], lhs parseState)) }
    | collection_open_kind quasiquoted_exprs collection_close_kind
        { SynQuasiquote.Collection(SynCollection($1, $2, lhs parseState)) }

unquote:
    | LPAREN UNQUOTE_KW expr RPAREN
        { SynQuasiquote.Unquote ($3, lhs parseState)}

splice_unquote:
    | LPAREN SPLICE_UNQUOTE_KW expr RPAREN
        { SynQuasiquote.SpliceUnquote ($3, lhs parseState)}

operators:
    | LPAREN operators_not_in_parens RPAREN { $2 }

op_text:
    | OP_PLUS               {  ("+",  (rhs parseState 1) )}
    | OP_DIV                {  ("/",  (rhs parseState 1) )}
    | OP_MULT               {  ("*",  (rhs parseState 1) )}
    | OP_MINUS              {  ("-",  (rhs parseState 1) )}
    | OP_GREATER            {  (">",  (rhs parseState 1) )}
    | OP_LESS               {  ("<",  (rhs parseState 1) )}
    | COLON_GREATER         {  (":>", (rhs parseState 1) )}
    | EQUALS                {  ("=",  (rhs parseState 1) )}
    | AMP_AMP               {  ("&&", (rhs parseState 1) )}
    | BAR_BAR               {  ("||", (rhs parseState 1) )}
    | OP_GREATER OP_GREATER {  (">>", (rhs2 parseState 1 2)) }
    | GREATER_EQUALS        {  (">=", (rhs parseState 1) )}
    | LESS_EQUALS           {  ("<=", (rhs parseState 1) )}
    | BANG_EQUALS           {  ("!=", (rhs parseState 1) )}

op_sym:
    | op_text { Syntax.mkSynSymbol (fst $1) (snd $1) }

operators_not_in_parens:
    | op_sym { SynOp.Infix($1, [], lhs parseState) }
    | op_sym expr_list { SynOp.Infix($1, $2, lhs parseState) }

set:
    | SET expr expr
        { SynExpr.Set($2, $3, lhs parseState) }
    // TODO: Report error
    | SET expr
        { let r = lhs parseState
          SynExpr.Set($2, Syntax.parserRecoveryExpr r, r) }
    // TODO
    | SET
        { let r = lhs parseState
          SynExpr.Set(Syntax.parserRecoveryExpr r, Syntax.parserRecoveryExpr r, r) }

let_use_mut_kw:
    | LET      { LetFlags.None }
    | LET_BANG { LetFlags.Bang }
    | USE      { LetFlags.Use }
    | USE_BANG { LetFlags.Bang ||| LetFlags.Use }
    | MUT      { LetFlags.Mutable }

let_or_use:
    | let_use_mut_kw syn_pat expr
        { SynExpr.LetOrUse($2, $3, $1, [], lhs parseState) }
    | let_use_mut_kw syn_pat
        { let r = lhs parseState
          SynExpr.LetOrUse($2, Syntax.parserRecoveryExpr r, $1, [], r) }
    | let_use_mut_kw
        { let r = lhs parseState
          SynExpr.LetOrUse(Syntax.parserRecoveryPat r, Syntax.parserRecoveryExpr r, $1, [], r) }
    | attribute_list let_use_mut_kw syn_pat expr
        { SynExpr.LetOrUse($3, $4, $2, $1, lhs parseState) }
    | attribute_list let_use_mut_kw syn_pat
        { let r = lhs parseState
          SynExpr.LetOrUse($3, Syntax.parserRecoveryExpr r, $2, $1, r) }
    | attribute_list let_use_mut_kw
        { let r = lhs parseState
          SynExpr.LetOrUse(Syntax.parserRecoveryPat r, Syntax.parserRecoveryExpr r, $2, $1, r) }

letstar:
    | LETSTAR binding_list_start expr_list
        { SynExpr.LetStar($2, $3, lhs parseState) }

type_name_text:
    | SYMBOL { ($1, (rhs parseState 1)) }
    | SYMBOL OP_LESS SYMBOL OP_GREATER
        { ($"{$1}<{$3}>", rhs2 parseState 1 4) }
    | SYMBOL OP_LESS SYMBOL COMMA symbol_comma_list OP_GREATER
        {
          let lst = $3 :: $5
          let args = String.concat "," lst
          ($"{$1}<{args}>", rhs2 parseState 1 6) }

syn_type_name:
    | type_name_text
        {
            let (text, range) = $1
            Syntax.mkSynTypeIdent text range
        }

type_name:
    | type_name_text
        {
            let (text, range) = $1
            Syntax.mkSynSymbol text range
        }

symbol_comma_list: rev_symbol_comma_list { List.rev $1 }
rev_symbol_comma_list:
    | SYMBOL { [$1] }
    | rev_symbol_comma_list COMMA SYMBOL { $3 :: $1 }

type_expr:
    | TYPEALIAS type_name syn_type
        { SynExpr.TypeAlias($2, $3, lhs parseState) }
    | TYPE type_name tuple_arg_pats %prec prec_type_expr
        { SynExpr.Type($2, $3, [], [], lhs parseState) }
    | TYPE type_name tuple_arg_pats member_list_start
        { SynExpr.Type($2, $3, $4, [], lhs parseState) }
    | attribute_list TYPE type_name tuple_arg_pats member_list_start
        { SynExpr.Type($3, $4, $5, $1, lhs parseState) }

tuple_arg_pats:
    | UNIT { SynPat.Args(SynArgPats.Tuple([]), lhs parseState) }
    | LPAREN RPAREN { SynPat.Args(SynArgPats.Tuple([]), lhs parseState) }
    | LBRACKET RBRACKET { SynPat.Args(SynArgPats.Tuple([]), lhs parseState) }
    | LPAREN syn_pat_trivia_list RPAREN
        { let lst = $2
          let lst =
            List.intersperse (SynPat.Trivia (SynPatternTriviaKind.Comma, rhs parseState 1)) lst

          SynPat.Args(SynArgPats.Tuple(lst), lhs parseState)
        }
    | LBRACKET syn_pat_trivia_list RBRACKET
        { let lst = $2
          let lst =
            List.intersperse (SynPat.Trivia (SynPatternTriviaKind.Comma, rhs parseState 1)) lst
          SynPat.Args(SynArgPats.Tuple(lst), lhs parseState)
        }

list_arg_pats:
    | UNIT { SynPat.Args(SynArgPats.List([]), lhs parseState) }
    | LPAREN RPAREN { SynPat.Args(SynArgPats.List([]), lhs parseState) }
    | LBRACKET RBRACKET { SynPat.Args(SynArgPats.List([]), lhs parseState) }
    | LPAREN syn_pat_trivia_list RPAREN
        { let lst = $2
          SynPat.Args(SynArgPats.List(lst), lhs parseState)
        }
    | LBRACKET syn_pat_trivia_list RBRACKET
        { let lst = $2
          SynPat.Args(SynArgPats.List(lst), lhs parseState)
        }

union_expr:
    | UNION type_name union_labels_or_members
        {
            let labels, members = Syntax.partitionChoices $3
            SynExpr.Union($2, labels, members, [] , lhs parseState)
        }
    | attribute_list UNION type_name union_labels_or_members
        {
            let labels, members = Syntax.partitionChoices $4
            SynExpr.Union($3, labels, members, $1 , lhs parseState)
        }

union_labels_or_members: rev_union_labels_or_members { List.rev $1 }
rev_union_labels_or_members:
    | union_label_or_member_parens { [$1] }
    | rev_union_labels_or_members union_label_or_member_parens { $2 :: $1 }

union_label_or_member_parens:
    | symbol { Choice1Of2(UnionCase($1, [], lhs parseState)) }
    | LPAREN union_label_or_member RPAREN { $2 }
    | LBRACKET union_label_or_member RBRACKET { $2 }

union_label_or_member:
    | member_in_parens { Choice2Of2($1) }
    | symbol
        { Choice1Of2(UnionCase($1, [], lhs parseState)) }
    | symbol union_fields
        { Choice1Of2(UnionCase($1, $2, lhs parseState)) }

union_fields: rev_union_fields { List.rev $1 }
rev_union_fields:
    | union_field { [$1] }
    | rev_union_fields union_field { $2 :: $1 }

union_field:
    | syn_type_name { UnionField.Type($1, lhs parseState) }
    | LPAREN symbol COLON syn_type_name RPAREN
        { UnionField.Named($2, $4, lhs parseState) }
    | LBRACKET symbol COLON syn_type_name RBRACKET
        { UnionField.Named($2, $4, lhs parseState) }

record_expr:
    | RECORD type_name record_labels_or_members
        {
            let members, labels = Syntax.partitionChoices $3
            SynExpr.Record($2, labels, members, [] , lhs parseState)
        }
    | attribute_list RECORD type_name record_labels_or_members
        {
            let members, labels = Syntax.partitionChoices $4
            SynExpr.Record($3, labels, members, $1 , lhs parseState)
        }

record_labels_or_members: rev_record_labels_or_members { List.rev $1 }
rev_record_labels_or_members:
    | record_label_or_member_parens { [$1] }
    | rev_record_labels_or_members record_label_or_member_parens { $2 :: $1 }

record_label_or_member_parens:
    | LPAREN record_label_or_member RPAREN { $2 }
    | LBRACKET record_label_or_member RBRACKET { $2 }

record_label_or_member:
    | member_in_parens { Choice1Of2($1) }
    | symbol COLON syn_type
        { Choice2Of2 (RecordLabel(RecordLabelKind.Default, $1, $3, lhs parseState)) }
    | MUT symbol COLON syn_type
        { Choice2Of2 (RecordLabel(RecordLabelKind.Mutable, $2, $4, lhs parseState)) }

record_members:
    | LPAREN MEMBERS member_list_start RPAREN { $3 }

record_init_expr:
    | RINIT record_init_list { SynExpr.RecordInit($2, lhs parseState) }

record_init_bar_list: rev_record_init_bar_list { List.rev $1 }
rev_record_init_bar_list:
    | record_init_init { [$1] }
    | rev_record_init_bar_list record_init_init { $2 :: $1 }

record_init_init:
    | record_init %prec prec_record_init
        { let s, e = $1
          SynInit(s, e, lhs parseState)
        }
    | record_init_parens { $1 }

record_init_list: rev_record_init_list { List.rev $1 }
rev_record_init_list:
    | record_init_parens { [$1] }
    | rev_record_init_list record_init_parens { $2 :: $1 }

record_init_parens:
    | LPAREN record_init RPAREN {
        let s, e = $2
        SynInit(s, e, lhs parseState)
     }
    | LBRACKET record_init RBRACKET {
        let s, e = $2
        SynInit(s, e, lhs parseState)
    }

record_init:
    | symbol expr { ($1, $2) }

attribute_list: rev_attribute_list { List.rev $1 }
rev_attribute_list:
    | attr_list { [$1] }
    | rev_attribute_list attr_list { $2 :: $1 }

attr_list:
    | HASH_BRACKET attributes RBRACKET
        { { Attributes = $2; Range = (lhs parseState) } }

attributes: rev_attributes { List.rev $1 }
rev_attributes:
    | attribute %prec prec_attribute { [$1] }
    | rev_attributes BAR attribute %prec prec_attribute_comma { $3 :: $1 }
    | rev_attributes DOT attribute { $3 :: $1 }

attribute:
    | syn_type_name LPAREN expr RPAREN
        { { TypeName = $1; ArgExpr = $3; Range = lhs parseState } }
    | syn_type_name LBRACKET expr RBRACKET
        { { TypeName = $1; ArgExpr = $3; Range = lhs parseState } }
    | syn_type_name
        { { TypeName = $1; ArgExpr = Syntax.UnitExpr <| lhs parseState; Range = lhs parseState } }

member_list_start:
    | member_list { $1 }

member_list: rev_member_list { List.rev $1 }
rev_member_list:
    | member %prec prec_member { [$1] }
    | rev_member_list member { $2 :: $1 }

member:
    | LPAREN member_in_parens RPAREN { $2 }

member_name:
    | MEMBER symbol { $2 }

member_get:
    | LPAREN MEMBER_GET tuple_arg_pats expr_list_or_empty RPAREN
        { SynMemberGet($3, $4, lhs parseState) }

member_set:
    | LPAREN MEMBER_SET tuple_arg_pats syn_pat expr_list_or_empty RPAREN
        { SynMemberSet($3, $4, $5, lhs parseState) }

member_member_in_parens:
    | member_name member_get { SynTypeMember.GetSet($1, Some($2), None, lhs parseState) }
    | member_name member_set { SynTypeMember.GetSet($1, None, Some($2), lhs parseState) }
    | member_name member_get member_set { SynTypeMember.GetSet($1, Some($2), Some($3), lhs parseState) }
    | member_name member_set member_get { SynTypeMember.GetSet($1, Some($3), Some($2), lhs parseState) }
    | member_name expr { SynTypeMember.Member($1, $2, lhs parseState) }

member_in_parens:
    | LET syn_pat expr
        { SynTypeMember.Let($2, $3, lhs parseState) }
    | MUT syn_pat expr
        { SynTypeMember.Mut($2, $3, lhs parseState) }
    | member_member_in_parens { $1 }
    | MEMBERFN syn_symbol list_arg_pats expr_list
        { SynTypeMember.MemberFn($2, $3, $4, (lhs parseState)) }
    | MEMBER FN syn_symbol list_arg_pats expr_list
        { SynTypeMember.MemberFn($3, $4, $5, (lhs parseState)) }
    | OVERRIDE syn_symbol expr
        { SynTypeMember.OverrideMember($2, $3, lhs parseState) }
    | OVERRIDE FN syn_symbol list_arg_pats expr_list
        { SynTypeMember.OverrideFn($3, $4, $5, (lhs parseState)) }
    | INTERFACE symbol_with_ops
        { SynTypeMember.Interface($2, [], lhs parseState)}
    | INTERFACE symbol_with_ops member_list
        { SynTypeMember.Interface($2, $3, lhs parseState)}

empty_bindings:
    | LPAREN RPAREN { [] }
    | LBRACKET RBRACKET { [] }

binding_list_start:
    | empty_bindings { $1 }
    | LPAREN binding_list RPAREN { $2 }
    | LBRACKET binding_list RBRACKET { $2 }

binding_list: rev_binding_list { List.rev $1 }
rev_binding_list:
    | binding %prec prec_binding { [$1] }
    | rev_binding_list binding { $2 :: $1 }

binding:
    | syn_pat expr { SynBinding($1, $2, lhs parseState) }

macro_name:
    | MACRO_NAME
        { let text = $1
          SynSymbol(Ident(text, lhs parseState))
        }

dot_method:
    | DOT_METHOD
        { let text = $1
          SynSymbol(Ident(text.TrimStart '.', lhs parseState))
        }

apply_method:
    | APPLY_METHOD
        { let text = $1
          SynSymbol(Ident(text.TrimStart '-', lhs parseState))
        }

keyword:
    | KEYWORD
        { let text = $1
          SynKeyword(Ident(text, lhs parseState))
        }

syn_type:
    // | syn_type_paren %prec prec_syn_type_paren { $1 }
    | LPAREN syn_type RPAREN %prec prec_syn_type_paren
        { SynType.Paren($2, lhs parseState) }
    | LBRACKET syn_type RBRACKET %prec prec_syn_type_paren
        { SynType.Paren($2, lhs parseState) }
    | syn_type OP_MULT syn_type_tuple_list %prec prec_syn_type_mult
        { SynType.Tuple(false, SynTypeTupleSegment.Type($1) :: SynTypeTupleSegment.Star(rhs parseState 2) :: $3, lhs parseState) }
    | syn_type THREAD_FIRST syn_type %prec prec_syn_type_array
        { SynType.Fun ($1, $3, lhs parseState) }
    | syn_type arrayTypeSuffixHelp %prec prec_syn_type_array
        { SynType.Array($2, $1, lhs parseState) }
    | SEQ { SynType.Ident(Ident("seq", rhs parseState 1)) }
    | SYMBOL %prec prec_syn_type
      { let text = $1
        if (text = "_") then
            SynType.Discard(lhs parseState)
        else
            SynType.Ident(Ident(text, lhs parseState)) }
    | syn_type OP_LESS syn_type OP_GREATER %prec prec_syn_type_generic
        { SynType.Generic($1, [$3], lhs parseState) }
    | syn_type OP_LESS syn_type COMMA syn_type_generic_list OP_GREATER %prec prec_syn_type_generic
        { SynType.Generic($1, $3 :: $5, lhs parseState) }

syn_type_generic_list: rev_syn_type_generic_list { List.rev $1 }
rev_syn_type_generic_list:
    | { [] }
    | syn_type %prec prec_syn_type_generic { [$1] }
    | rev_syn_type_generic_list COMMA syn_type %prec prec_syn_type_generic { $3 :: $1 }

arrayTypeSuffixHelp: arrayTypeSuffix %prec prec_syn_type_array { $1 }
arrayTypeSuffix:
  | LBRACKET RBRACKET { 1 }
  | LBRACKET COMMA RBRACKET { 2 }
  | LBRACKET COMMA COMMA RBRACKET { 3 }
  | LBRACKET COMMA COMMA COMMA RBRACKET { 4 }
  | LBRACKET COMMA COMMA COMMA COMMA RBRACKET { 5 }
  | LBRACKET COMMA COMMA COMMA COMMA COMMA RBRACKET { 6 }

syn_type_tuple_list: rev_syn_type_tuple_list %prec prec_syn_type_mult { List.rev $1 }
rev_syn_type_tuple_list:
    | syn_type %prec prec_syn_type_mult { [SynTypeTupleSegment.Type($1)] }
    | rev_syn_type_tuple_list OP_MULT syn_type %prec prec_syn_type_mult { SynTypeTupleSegment.Type($3) :: SynTypeTupleSegment.Star(rhs parseState 2) :: $1 }

constant:
    | rawConstant { ($1, (rhs parseState 1))}

rawConstant:
    | STRING
        { let (raw, kind, _) = $1
          SynConst.String(raw, kind, (lhs parseState))}
    | INT8
      { if snd $1 then errorR(mkDiagnosticWithText (SR.lexOutsideEightBitSigned(), lhs parseState))
        SynConst.SByte(fst $1) }

    | UINT8
      { SynConst.Byte $1 }

    | INT16
      { if snd $1 then errorR(mkDiagnosticWithText (SR.lexOutsideSixteenBitSigned(), lhs parseState))
        SynConst.Int16 (fst $1) }

    | UINT16
      { SynConst.UInt16 $1 }

    | INT32
      { if snd $1 then errorR(mkDiagnosticWithText (SR.lexOutsideThirtyTwoBitSigned(), lhs parseState))
        SynConst.Int32 (fst $1) }

    | UINT32
      { SynConst.UInt32 $1 }

    | INT64
      { if snd $1 then errorR(mkDiagnosticWithText (SR.lexOutsideSixtyFourBitSigned(), lhs parseState))
        SynConst.Int64 (fst $1) }

    | UINT64
      { SynConst.UInt64 $1 }

    | NATIVEINT
      { if snd $1 then errorR(mkDiagnosticWithText (SR.lexOutsideNativeSigned(), lhs parseState))
        SynConst.IntPtr(fst $1) }

    | UNATIVEINT
      { SynConst.UIntPtr $1 }

    | IEEE32
      { SynConst.Single $1 }

    | IEEE64
      { SynConst.Double $1 }

    | DECIMAL { SynConst.Decimal($1)}

    | TRUE { SynConst.Bool(true)}
    | FALSE { SynConst.Bool(false)}
    | NIL { SynConst.Nil }
    | UNIT { SynConst.Unit }
    | CHAR
        { let text = $1
          SynConst.Char(parseChar text) }

function_def:
    | FN function_def_name function_def_args expr_list %prec prec_fn
        { SynExpr.FunctionDef($2, FunctionFlags.None, $3, $4, (lhs parseState)) }
    | FN INLINE function_def_name function_def_args expr_list %prec prec_fn
        { SynExpr.FunctionDef($3, FunctionFlags.Inline, $4, $5, (lhs parseState)) }
    | FN REC INLINE function_def_name function_def_args expr_list %prec prec_fn
        { SynExpr.FunctionDef($4, FunctionFlags.Recursive ||| FunctionFlags.Inline, $5, $6, (lhs parseState)) }
    | FN REC function_def_name function_def_args expr_list %prec prec_fn
        { SynExpr.FunctionDef($3, FunctionFlags.Recursive, $4, $5, (lhs parseState)) }
    | FN function_def_args expr_list %prec prec_lambda_def
        { SynExpr.LambdaDef(SynLambda($2, $3, (lhs parseState))) }
    | FNSTAR function_def_args expr_list
        { SynExpr.LambdaDef(SynLambda($2, $3, (lhs parseState))) }
    | invalid_function_def %prec prec_invalid_fn { $1 }

function_def_name:
    | symbol { $1 }
    | symbol OP_GREATER symbol { Symbol.concat ">" [$1; $3] }

function_def_args: list_arg_pats { $1 }

invalid_function_def:
    // TODO: Report
    | FN %prec prec_invalid_fn
        { SynExpr.LambdaDef(SynLambda(mkRecoveryPat parseState, [], (lhs parseState))) }
    // TODO: Report
    | FN function_def_name %prec prec_invalid_fn
        { SynExpr.FunctionDef($2, FunctionFlags.None, mkRecoveryPat parseState, [], lhs parseState) }
    // TODO: Report
    | FN function_def_args %prec prec_invalid_fn
        { SynExpr.LambdaDef(SynLambda(mkRecoveryPat parseState, [], (lhs parseState))) }
    // TODO: Report
    | FN function_def_name function_def_args %prec prec_invalid_fn
        { SynExpr.FunctionDef($2, FunctionFlags.None, $3, [], (lhs parseState)) }
    | FN INLINE function_def_name function_def_args %prec prec_invalid_fn
        { SynExpr.FunctionDef($3, FunctionFlags.Inline, $4, [], (lhs parseState)) }

function_call:
    | expr expr_list { Syntax.mkFunctionCallOrCexpr $1 $2 (lhs parseState)}
    | expr { SynExpr.FunctionCall($1, [], (lhs parseState))}

function_call_args:
    | empty_call_args { $1 }
    | expr_list { $1 }

empty_call_args:
    | { [] }

match_expr:
    | MATCH expr match_list
        { SynExpr.Match ($2, $3, lhs parseState)}
    // TODO: report
    | MATCH expr
        { let r = lhs parseState;
          SynExpr.Match ($2, [], r)}
    // TODO: report
    | MATCH
        { let r = lhs parseState;
          SynExpr.Match (Syntax.parserRecoveryExpr r, [], r)}

match_list: rev_match_list { List.rev $1 }
rev_match_list:
    | match_start { [$1] }
    | rev_match_list match_start { $2 :: $1 }

match_start:
    | lparen_or_lbracket match rparen_or_rbracket { $2 }
    // TODO: report
    | lparen_or_lbracket rparen_or_rbracket {
        Syntax.parserRecoveryMatch (lhs parseState)
     }

match:
    | syn_pat
        { SynMatch.SynMatch($1, None, [], lhs parseState) }

    | syn_pat expr_list
        { SynMatch.SynMatch($1, None, $2, lhs parseState) }

    | syn_pat LPAREN WHEN expr RPAREN expr_list
        { SynMatch.SynMatch($1, Some($4), $6, lhs parseState) }

syn_trivia_kind:
    | COMMA { SynPatternTriviaKind.Comma }
    | DOT { SynPatternTriviaKind.Dot }
    | COLON_COLON { SynPatternTriviaKind.ColonColon }

syn_pat_trivia:
    | syn_trivia_kind { SynPat.Trivia($1, rhs parseState 1) }

syn_pat_trivia_list: rev_syn_pat_trivia_list { List.rev $1 }
rev_syn_pat_trivia_list:
    | syn_pat %prec prec_syn_pat { [$1] }
    | rev_syn_pat_trivia_list syn_pat_trivia syn_pat %prec prec_syn_pat { $3 :: $2 :: $1 }
    | rev_syn_pat_trivia_list syn_pat %prec prec_syn_pat { $2 :: $1 }

pat_open_kind:
    | LPAREN %prec prec_syn_pat_open { CollectionKind.Paren }
    | LBRACKET %prec prec_syn_pat_open { CollectionKind.Bracket }
    | BRACKET_BAR %prec prec_syn_pat_open { CollectionKind.FsArray }
    | PAREN_BAR %prec prec_syn_pat_open  { CollectionKind.FsList }

syn_pat:
    | constant %prec prec_match_pattern_const { SynPat.Const(fst $1, snd $1) }
    | pat_open_kind syn_pat COLON syn_type collection_close_kind %prec prec_syn_type
        { SynPat.Typed($2, $4, lhs parseState) }
    | SYMBOL %prec prec_syn_pat {
        let text = $1
        if (text = "_") then
            SynPat.Discard (lhs parseState)
        else
            SynPat.Named (Syntax.mkSynSymbol text (rhs parseState 1), (rhs parseState 1)) }
    | pat_open_kind COLON_QMARK syn_type collection_close_kind
        { SynPat.IsInst($3, lhs parseState) }
    | pat_open_kind COLON_QMARK syn_type syn_pat collection_close_kind
        { let r = lhs parseState
          SynPat.mkInParens (SynPat.As(SynPat.IsInst($3, rhs2 parseState 2 3), $4, r)) r
        }
    | pat_open_kind collection_close_kind %prec prec_syn_pat
        { SynPat.Collection(SynCollection($1, [], lhs parseState)) }

    | pat_open_kind syn_pat_trivia_list collection_close_kind %prec prec_syn_pat
        { SynPat.Collection(SynCollection($1, $2, lhs parseState)) }
    | LPAREN BANG_TUPLE syn_pat_trivia_list RPAREN
    { let lst = List.intersperse (SynPat.Trivia (SynPatternTriviaKind.Comma, rhs parseState 1)) $3
      SynPat.Collection(SynCollection(CollectionKind.Paren, lst, lhs parseState))
    }
