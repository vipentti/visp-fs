// FsLex lexer
{
// Copyright 2023 Ville Penttinen
// Distributed under the MIT License.
// https://github.com/vipentti/visp-fs/blob/main/LICENSE.md

module Visp.Compiler.Lexer

open FSharp.Text.Lexing
open System
open Visp.Compiler.SyntaxParser
open Visp.Compiler.ParseHelpers
open Visp.Compiler.LexHelpers

exception SyntaxError of string

let lexeme = LexBuffer<_>.LexemeString

let newline (lexbuf: LexBuffer<_>) =
    lexbuf.EndPos <- lexbuf.EndPos.NextLine

let outputToken lexbuf =
  (sprintf "token: '%s' Line: %d Column: %d" (lexeme lexbuf) (lexbuf.StartPos.Line+1) lexbuf.StartPos.Column)

let unexpected_char mode (lexbuf: LexBuffer<_>) =
  let file = lexbuf.EndPos.FileName
  failwith (sprintf "%s SyntaxError: Unexpected char: '%s' %s:line %d Column: %d" mode (lexeme lexbuf) file (lexbuf.StartPos.Line+1) lexbuf.StartPos.Column)

let startString nesting (lexbuf: LexBuffer<_>) =
    let buf = StringBuffer()
    let m = lexbuf.LexemeRange
    let startp = lexbuf.StartPos
    let fin =
        LexerStringFinisher (fun buf kind context cont ->
            // Adjust the start-of-token mark back to the true start of the token
            lexbuf.StartPos <- startp

            let isPart = context.HasFlag(LexerStringFinisherContext.InterpolatedPart)
            let isTripleQuote = context.HasFlag(LexerStringFinisherContext.TripleQuote)

            let synStringKind =
              if isTripleQuote then
                if kind.IsInterpolated then
                  Syntax.SynStringKind.InterpolatedTripleQuote nesting
                else
                  Syntax.SynStringKind.TripleQuote
              else
                if kind.IsInterpolated then
                  Syntax.SynStringKind.Interpolated nesting
                else
                  Syntax.SynStringKind.Regular

            // if kind.IsInterpolated then
            //   let s = buf.ToString()
            //   // if kind.IsInterpolatedFirst then
            //   //   if isPart then
            //   //     INTERP_STRING_BEGIN_PART (s, synStringKind, cont)
            //   //   else
            //   //     INTERP_STRING_BEGIN_END (s, synStringKind, cont)
            //   // else
            //   //   if isPart then
            //   //     INTERP_STRING_PART (s, cont)
            //   //   else
            //   //     INTERP_STRING_END (s, cont)
            //   STRING(buf.ToString(), Syntax.SynStringKind.Interpolated, cont)
            // else
            STRING(buf.ToString(), synStringKind, cont)
        )

    buf,fin,m
}

let int = ['-' '+']? ['0'-'9']+ ['l' 'L']?
let digit = ['0'-'9']
let frac = '.' digit+
let exp = ['e' 'E'] ['-' '+']? digit+
let decimal = '-'? digit* frac? exp?
let letter = ['A'-'Z'] | ['a'-'z']

let SymbolicStartCharacters = ['%' '+' '-' '!' '?' '_' '-' '*' '=' '<' '>' '&' '^' ]
let SymbolicExtra = [ '.' '\'' '/' ]

// https://github.com/dotnet/fsharp/blob/ade794633b4bb495da85c92ee780068b9c6f7344/src/Compiler/lex.fsl#L300
let escape_char = ('\\' ( '\\' | "\"" | '\'' | 'a' | 'f' | 'v' | 'n' | 't' | 'b' | 'r'))

let ident_start_char = letter | SymbolicStartCharacters
let ident_char = ( ident_start_char | digit | SymbolicExtra )
let ident = ident_start_char ident_char*

let anyspace = [' ' '\t' '\r' '\n']
let whitespace = [' ' '\t']+
let newline = '\r' | '\n' | "\r\n"
let nonWhitespace = [^ ' ' '\t' '\r' '\n']
// let possible_char = [.]

let charWords = (
  "newline"
    | "linefeed"
    | "cr"
    | "lf"
    | "return"
    | "tab"
    | "nul"
    | "null"
    | "backspace"
    | "space"
)
let unicodeChar = ['0'-'9' 'a'-'f' 'A'-'F']
let unicodeChars =
  unicodeChar unicodeChar unicodeChar unicodeChar

let punct = [
  '{' '}'
  '(' ')'
  '[' ']'
  ]

let propShort = letter ident_char*

rule token (args: LexArgs) (skip: bool) = parse
  | whitespace { token args skip lexbuf }
  | newline    { newline lexbuf; token args skip lexbuf }
  | ";" [^'\n''\r']* { token args skip lexbuf  }
  | eof        { EOF }

  // punct
  | '('           { LPAREN }
  | ')'           { RPAREN }
  | '{'           { LBRACE }
  | '}'           { RBRACE }
  | '['           { LBRACKET }
  | ']'           { RBRACKET }
  | "::"           { COLON_COLON }
  | ':' anyspace+ { COLON }
  | ','           { COMMA }
  | '|'           { BAR }

  | "..." { SYMBOL (lexeme lexbuf) }

  | "#nowarn" { HASH_IDENT ((lexeme lexbuf).TrimStart('#'))}

  | '+' anyspace+   { OP_PLUS }
  | '-' anyspace+   { OP_MINUS }
  | '.' anyspace+ { DOT }
  | '+' propShort { PROP_PLUS (lexeme lexbuf) }
  | "#(" { HASH_PAREN }
  | "#[" { HASH_BRACKET }
  | "#{" { HASH_BRACE }
  | ".." { DOTDOT }
  | "'" { QUOTE_SYM }
  | ".[" { DOT_BRACKET }
  | ".+" { DOT_PLUS }
  | '.' propShort { DOT_METHOD (lexeme lexbuf) }
  | '-' propShort { APPLY_METHOD (lexeme lexbuf) }
  | '@' { AT }
  | "#\\" charWords { CHAR (lexeme lexbuf) }
  | "#\\u" unicodeChars { CHAR (lexeme lexbuf) }
  | "#\\U" unicodeChars { CHAR (lexeme lexbuf) }
  | "#\\" nonWhitespace { CHAR (lexeme lexbuf) }
  | whitespace { token args skip lexbuf }
  | newline    { newline lexbuf; token args skip lexbuf }
  | int        {
      let text = (lexeme lexbuf)
      if text.EndsWith('L') then
        INT64 (int64 (text.TrimEnd('L')))
      else
        INT32 (int (text.TrimEnd('l'))) }
  | decimal    { DECIMAL (decimal (lexeme lexbuf)) }

  | '+'  { OP_PLUS }
  | '-'  { OP_MINUS }
  | "#()"     { UNIT }
  | "unit"     { UNIT }
  | "true"     { TRUE }
  | "false"    { FALSE }
  | "nil"      { NIL }
  | '"'
    { let buf, fin, m = startString 0 lexbuf
      // TODO: validate
      singleQuoteString (buf, fin, m, LexerStringKind.String, args) skip lexbuf
    }
  | "#r" '"' '"' '"'
    { let buf, fin, m = startString 0 lexbuf
      // TODO: validate
      tripleQuoteString (buf, fin, m, LexerStringKind.String, args) skip lexbuf
    }
  | '$' '"' '"' '"'
    { let buf, fin, m = startString 1 lexbuf
      // TODO: validate
      tripleQuoteString (buf, fin, m, LexerStringKind.InterpolatedStringFirst, args) skip lexbuf
    }

  | ('$'+) '"' '"' '"'
    {
      let nest = lexeme lexbuf |> Seq.takeWhile (fun c -> c = '$') |> Seq.length
      let buf, fin, m = startString nest lexbuf
      // TODO: validate
      tripleQuoteString (buf, fin, m, LexerStringKind.InterpolatedStringFirst, args) skip lexbuf
    }

  | '"' '"' '"'
    { let buf, fin, m = startString 0 lexbuf
      // TODO: validate
      tripleQuoteString (buf, fin, m, LexerStringKind.String, args) skip lexbuf
    }

  | '$' '"'
    { let buf, fin, m = startString 1 lexbuf
      // TODO: validate
      singleQuoteString (buf, fin, m, LexerStringKind.InterpolatedStringFirst, args) skip lexbuf
    }

  | '*'        { OP_MULT }
  | '/'        { OP_DIV }
  | ':' ident_char+ { KEYWORD (lexeme lexbuf) }
  | ident      {
      let text = lexeme lexbuf
      symbolOrKeyword text
    }
  | _ { unexpected_char "token" lexbuf }

and tokenStream (args: LexArgs) (skip: bool) = parse
  | whitespace { tokenStream args skip lexbuf }
  | newline    { newline lexbuf; tokenStream args skip lexbuf }
  | ";" [^'\n''\r']* { tokenStream args skip lexbuf  }
  | eof        { EOF }

  | "#line" { HASH_IDENT ((lexeme lexbuf).TrimStart('#'))}

  // punct
  | '('           { LPAREN }
  | ')'           { RPAREN }
  | '{'           { LBRACE }
  | '}'           { RBRACE }
  | '['           { LBRACKET }
  | ']'           { RBRACKET }
  | "::" anyspace+ { COLON_COLON }
  | ':' anyspace+ { COLON }
  | ','           { COMMA }
  | '|'           { BAR }
  | '.' anyspace+ { DOT }
  | "#("          { HASH_PAREN }
  | "#["          { HASH_BRACKET }
  | "#{"          { HASH_BRACE }

  | "..." { SYMBOL (lexeme lexbuf) }

  // operators
  | '-' anyspace+   { SYMBOL "-" }
  | '*' anyspace+   { SYMBOL "*" }
  | '+' anyspace+   { SYMBOL "+" }
  | '/' anyspace+   { SYMBOL "/" }

  // Constants
  | "#()"      { UNIT }
  | "()"       { UNIT }
  | "unit"     { UNIT }
  | "true"     { TRUE }
  | "false"    { FALSE }
  | "nil"      { NIL }
  | "#\\" charWords { CHAR (lexeme lexbuf) }
  | "#\\u" unicodeChars { CHAR (lexeme lexbuf) }
  | "#\\U" unicodeChars { CHAR (lexeme lexbuf) }
  | "#\\" nonWhitespace { CHAR (lexeme lexbuf) }
  | int {
      let text = (lexeme lexbuf)
      if text.EndsWith('L') then
        INT64 (int64 (text.TrimEnd('L')))
      else
        INT32 (int (text.TrimEnd('l'))) }
  | decimal    { DECIMAL (decimal (lexeme lexbuf)) }

  | '$' '"'
    { let buf, fin, m = startString 1 lexbuf
      // TODO: validate
      singleQuoteString (buf, fin, m, LexerStringKind.InterpolatedStringFirst, args) skip lexbuf
    }

  | '"'
    { let buf, fin, m = startString 0 lexbuf
      // TODO: validate
      singleQuoteString (buf, fin, m, LexerStringKind.String, args) skip lexbuf
    }

  | '$' '"' '"' '"'
    { let buf, fin, m = startString 1 lexbuf
      // TODO: validate
      tripleQuoteString (buf, fin, m, LexerStringKind.InterpolatedStringFirst, args) skip lexbuf
    }

  | ('$'+) '"' '"' '"'
    {
      let nest = lexeme lexbuf |> Seq.takeWhile (fun c -> c = '$') |> Seq.length
      let buf, fin, m = startString nest lexbuf
      // TODO: validate
      tripleQuoteString (buf, fin, m, LexerStringKind.InterpolatedStringFirst, args) skip lexbuf
    }

  | '"' '"' '"'
    { let buf, fin, m = startString 0 lexbuf
      // TODO: validate
      tripleQuoteString (buf, fin, m, LexerStringKind.String, args) skip lexbuf
    }

  | "#r" '"' '"' '"'
    { let buf, fin, m = startString 0 lexbuf
      // TODO: validate
      tripleQuoteString (buf, fin, m, LexerStringKind.String, args) skip lexbuf
    }

  // Exprs
  | ':' ident_char+ { KEYWORD (lexeme lexbuf) }
  | '.' ident_char+ {
      let text = lexeme lexbuf;
      SYMBOL text }
  | '+' ident_char+ {
      let text = lexeme lexbuf;
      SYMBOL text }
  | '-' ident_char+ {
      let text = lexeme lexbuf;
      SYMBOL text }
  | ident      {
    let text = lexeme lexbuf
    if args.mode.IsQuasiquoteMode then
      if text = "unquote" then
        UNQUOTE_KW
      else if text = "splice-unquote" then
        SPLICE_UNQUOTE_KW
      else
        SYMBOL text
    else
      SYMBOL text }
  | _ { unexpected_char "tokenStream" lexbuf }

and singleQuoteString (sargs: LexerStringArgs) (skip: bool) = parse
 | '"'
    { let (buf, fin, _m, kind, args) = sargs
      let cont = LexCont.Token(args.stringNest)
      fin.Finish buf kind (LexerStringFinisherContext()) cont
    }
 | newline
  { newline lexbuf;
    let (buf, _fin, m, kind, args) = sargs
    addUnicodeString buf (lexeme lexbuf)
    singleQuoteString sargs skip lexbuf
  }
 | escape_char
   {
     let (buf, _fin, m, kind, args) = sargs
     addUnicodeString buf (lexeme lexbuf)
     singleQuoteString sargs skip lexbuf
   }
  | _
    { let (buf, _fin, m, kind, args) = sargs
      addUnicodeString buf (lexeme lexbuf)
      singleQuoteString sargs skip lexbuf }

and tripleQuoteString (sargs: LexerStringArgs) (skip: bool) = parse
 | '"' '"' '"'
    { let (buf, fin, _m, kind, args) = sargs
      let cont = LexCont.Token(args.stringNest)
      fin.Finish buf kind (LexerStringFinisherContext.TripleQuote) cont
    }
 | newline
  { newline lexbuf;
    let (buf, _fin, m, kind, args) = sargs
    addUnicodeString buf (lexeme lexbuf)
    tripleQuoteString sargs skip lexbuf
  }
 // | escape_char
 //   {
 //     let (buf, _fin, m, kind, args) = sargs
 //     addUnicodeString buf (lexeme lexbuf)
 //     singleQuoteString sargs skip lexbuf
 //   }
 | _
    { let (buf, _fin, m, kind, args) = sargs
      addUnicodeString buf (lexeme lexbuf)
      tripleQuoteString sargs skip lexbuf }
